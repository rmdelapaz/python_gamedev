<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Master save/load systems in game development. Learn serialization, save file management, and game state persistence techniques.">
    <title>Save/Load Game State - Game Architecture</title>
    <link rel="stylesheet" href="/styles/main.css">
    <link rel="stylesheet" href="/styles/enhanced.css">
    <link rel="icon" href="/favicon.png">
    <script type="module">
      import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
      mermaid.initialize({ startOnLoad: true });
    </script>
</head>
<body>
    <!-- Skip to main content for accessibility -->
    <a href="#main-content" class="skip-to-main">Skip to main content</a>
    
    <!-- Progress indicator -->
    <div class="progress-indicator" role="progressbar" aria-label="Page scroll progress">
        <div class="progress-bar"></div>
    </div>
    
    <main id="main-content">
    <header role="banner">
        <h1>Save/Load Game State</h1>
        <div class="reading-time" aria-label="Estimated reading time"></div>
    </header>
    
    <!-- Breadcrumb Navigation -->
    <nav class="breadcrumb" aria-label="Breadcrumb">
        <a href="index.html">Course Home</a>
        <span class="separator">›</span>
        <span class="current">Intermediate Module - Section 1: Game Architecture - Lesson 5</span>
    </nav>

    <h2>Persisting and Restoring Game Progress</h2>
    
    <div style="background-color: #f0f8ff; padding: 20px; border-radius: 10px; margin: 20px 0;">
        <p>Save systems preserve player progress and game state! Learn how to serialize game data, manage save files, handle different save formats, and create robust save/load systems that never lose player data! 💾🎮</p>
    </div>

    <h2>Understanding Save Systems</h2>
    
    <div style="background-color: #fff5f5; padding: 20px; border-radius: 10px; margin: 20px 0;">
        <h3>📷 The Photo Album Analogy</h3>
        <p>Think of save systems like organizing photo albums:</p>
        <ul>
            <li><strong>Save Data:</strong> Individual photos capturing moments</li>
            <li><strong>Save Slots:</strong> Different photo albums</li>
            <li><strong>Serialization:</strong> Developing photos from negatives</li>
            <li><strong>Deserialization:</strong> Viewing photos to remember</li>
            <li><strong>Compression:</strong> Storing photos efficiently</li>
            <li><strong>Versioning:</strong> Dating and organizing photos</li>
        </ul>
    </div>

    <div class="mermaid">
    graph TD
        A["Save System"] --> B["Data Collection"]
        A --> C["Serialization"]
        A --> D["Storage"]
        A --> E["Loading"]
        
        B --> F["Player State"]
        B --> G["World State"]
        B --> H["Game Progress"]
        
        C --> I["JSON"]
        C --> J["Binary"]
        C --> K["Custom Format"]
        
        D --> L["Local Storage"]
        D --> M["Cloud Save"]
        D --> N["Database"]
        
        E --> O["Validation"]
        E --> P["Deserialization"]
        E --> Q["State Restoration"]
    </div>

    <h2>Interactive Save/Load System Demo</h2>
    
    <div class="canvas-wrapper" style="text-align: center;">
        <canvas id="saveCanvas" width="600" height="400" style="border: 1px solid #333; background-color: #1a1a1a; display: inline-block;"></canvas>
    </div>
    <div style="text-align: center; margin-top: 10px;">
        <p>Build a game state and test saving/loading!</p>
        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(100px, 1fr)); gap: 10px; max-width: 600px; margin: 10px auto;">
            <button onclick="movePlayer()">Move Player</button>
            <button onclick="collectItem()">Collect Item</button>
            <button onclick="spawnEnemy()">Add Enemy</button>
            <button onclick="increaseScore()">+100 Score</button>
            <button onclick="unlockAchievement()">Achievement</button>
            <button onclick="completeLevel()">Complete Level</button>
        </div>
        <div style="margin-top: 10px; display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; max-width: 600px; margin: 10px auto;">
            <button onclick="saveGame(1)" style="background-color: #4CAF50;">💾 Save Slot 1</button>
            <button onclick="saveGame(2)" style="background-color: #4CAF50;">💾 Save Slot 2</button>
            <button onclick="saveGame(3)" style="background-color: #4CAF50;">💾 Save Slot 3</button>
            <button onclick="loadGame(1)" style="background-color: #2196F3;">📂 Load Slot 1</button>
            <button onclick="loadGame(2)" style="background-color: #2196F3;">📂 Load Slot 2</button>
            <button onclick="loadGame(3)" style="background-color: #2196F3;">📂 Load Slot 3</button>
        </div>
        <div style="margin-top: 10px;">
            <button onclick="quickSave()">Quick Save (F5)</button>
            <button onclick="quickLoad()">Quick Load (F9)</button>
            <button onclick="autoSave()">Auto Save</button>
            <button onclick="exportSave()">Export Save</button>
            <button onclick="importSave()">Import Save</button>
            <button onclick="resetGame()">Reset Game</button>
        </div>
        <div style="margin-top: 10px;">
            <label>Save Format: 
                <select id="saveFormat" onchange="setSaveFormat(this.value)">
                    <option value="json">JSON</option>
                    <option value="binary">Binary</option>
                    <option value="compressed">Compressed</option>
                </select>
            </label>
            <label>
                <input type="checkbox" id="encryptSaves" onchange="toggleEncryption()"> Encrypt Saves
            </label>
            <label>
                <input type="checkbox" id="cloudSync" onchange="toggleCloudSync()"> Cloud Sync
            </label>
        </div>
        <div style="margin-top: 10px; background-color: rgba(0,0,0,0.5); padding: 10px; border-radius: 5px;">
            <p style="margin: 5px;">Score: <span id="score">0</span> | Level: <span id="level">1</span> | Items: <span id="items">0</span></p>
            <p style="margin: 5px;">Position: (<span id="playerX">300</span>, <span id="playerY">200</span>) | Enemies: <span id="enemies">0</span></p>
            <p style="margin: 5px;">Achievements: <span id="achievements">0</span> | Play Time: <span id="playTime">0:00</span></p>
        </div>
        <div id="saveSlots" style="margin-top: 10px; display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; max-width: 600px; margin: 10px auto;">
            <!-- Save slot info will be displayed here -->
        </div>
        <div id="saveDataPreview" style="margin-top: 10px; height: 100px; overflow-y: auto; border: 1px solid #333; padding: 5px; text-align: left; font-size: 10px; background-color: rgba(0,0,0,0.5); font-family: monospace;">
            <!-- Save data preview will appear here -->
        </div>
    </div>

    <script src="architecture_save_load.js"></script>

    <h2>Basic Save/Load Implementation</h2>
    
    <pre class="language-python"><code>import json
import pickle
import os
import time
import hashlib
import base64
from typing import Dict, Any, Optional
from dataclasses import dataclass, asdict
from datetime import datetime

@dataclass
class SaveData:
    """Container for save game data"""
    version: str = "1.0.0"
    timestamp: float = None
    play_time: float = 0
    
    # Player data
    player_name: str = "Player"
    player_level: int = 1
    player_health: int = 100
    player_position: tuple = (0, 0)
    player_inventory: list = None
    
    # Game progress
    current_level: int = 1
    completed_levels: list = None
    score: int = 0
    achievements: list = None
    
    # World state
    world_seed: int = 0
    enemies: list = None
    items: list = None
    
    def __post_init__(self):
        if self.timestamp is None:
            self.timestamp = time.time()
        if self.player_inventory is None:
            self.player_inventory = []
        if self.completed_levels is None:
            self.completed_levels = []
        if self.achievements is None:
            self.achievements = []
        if self.enemies is None:
            self.enemies = []
        if self.items is None:
            self.items = []

class SaveManager:
    """Manages game saves and loads"""
    def __init__(self, save_directory: str = "saves"):
        self.save_directory = save_directory
        self.current_save_data = SaveData()
        self.auto_save_interval = 300  # 5 minutes
        self.last_auto_save = time.time()
        
        # Create save directory if it doesn't exist
        if not os.path.exists(save_directory):
            os.makedirs(save_directory)
    
    def save_game(self, slot: int = 1, save_data: SaveData = None) -> bool:
        """Save game to specified slot"""
        if save_data is None:
            save_data = self.current_save_data
        
        # Update timestamp
        save_data.timestamp = time.time()
        
        # Generate filename
        filename = self.get_save_filename(slot)
        filepath = os.path.join(self.save_directory, filename)
        
        try:
            # Save as JSON
            with open(filepath, 'w') as f:
                json.dump(asdict(save_data), f, indent=2)
            
            print(f"Game saved to slot {slot}")
            return True
            
        except Exception as e:
            print(f"Failed to save game: {e}")
            return False
    
    def load_game(self, slot: int = 1) -> Optional[SaveData]:
        """Load game from specified slot"""
        filename = self.get_save_filename(slot)
        filepath = os.path.join(self.save_directory, filename)
        
        if not os.path.exists(filepath):
            print(f"No save found in slot {slot}")
            return None
        
        try:
            # Load from JSON
            with open(filepath, 'r') as f:
                data = json.load(f)
            
            # Create SaveData object
            save_data = SaveData(**data)
            
            # Validate save data
            if self.validate_save(save_data):
                self.current_save_data = save_data
                print(f"Game loaded from slot {slot}")
                return save_data
            else:
                print(f"Save file corrupted in slot {slot}")
                return None
                
        except Exception as e:
            print(f"Failed to load game: {e}")
            return None
    
    def validate_save(self, save_data: SaveData) -> bool:
        """Validate save data integrity"""
        # Check version compatibility
        if save_data.version != "1.0.0":
            print(f"Save version {save_data.version} not compatible")
            return False
        
        # Check data integrity
        if save_data.player_health < 0:
            return False
        if save_data.current_level < 1:
            return False
        
        return True
    
    def get_save_filename(self, slot: int) -> str:
        """Generate save filename for slot"""
        return f"savegame_{slot}.json"
    
    def quick_save(self) -> bool:
        """Quick save to slot 0"""
        return self.save_game(0)
    
    def quick_load(self) -> Optional[SaveData]:
        """Quick load from slot 0"""
        return self.load_game(0)
    
    def auto_save(self) -> bool:
        """Auto save if interval has passed"""
        current_time = time.time()
        if current_time - self.last_auto_save >= self.auto_save_interval:
            self.last_auto_save = current_time
            return self.save_game(99)  # Auto save slot
        return False
    
    def list_saves(self) -> list:
        """List all available saves"""
        saves = []
        for filename in os.listdir(self.save_directory):
            if filename.startswith("savegame_") and filename.endswith(".json"):
                filepath = os.path.join(self.save_directory, filename)
                try:
                    with open(filepath, 'r') as f:
                        data = json.load(f)
                    
                    slot = int(filename.split('_')[1].split('.')[0])
                    saves.append({
                        'slot': slot,
                        'timestamp': data.get('timestamp', 0),
                        'play_time': data.get('play_time', 0),
                        'level': data.get('current_level', 1),
                        'score': data.get('score', 0)
                    })
                except:
                    continue
        
        return sorted(saves, key=lambda x: x['slot'])
    
    def delete_save(self, slot: int) -> bool:
        """Delete save from slot"""
        filename = self.get_save_filename(slot)
        filepath = os.path.join(self.save_directory, filename)
        
        if os.path.exists(filepath):
            try:
                os.remove(filepath)
                print(f"Save deleted from slot {slot}")
                return True
            except Exception as e:
                print(f"Failed to delete save: {e}")
                return False
        return False</code></pre>

    <h2>Advanced Save Features</h2>
    
    <pre class="language-python"><code># Binary save system with compression
import zlib
import struct

class BinarySaveManager(SaveManager):
    """Binary save system with compression"""
    
    def save_binary(self, slot: int, save_data: SaveData) -> bool:
        """Save game data as compressed binary"""
        filename = f"savegame_{slot}.dat"
        filepath = os.path.join(self.save_directory, filename)
        
        try:
            # Serialize to binary
            binary_data = pickle.dumps(asdict(save_data))
            
            # Compress
            compressed = zlib.compress(binary_data, level=9)
            
            # Add header with version and checksum
            version = struct.pack('I', 1)  # Version 1
            checksum = struct.pack('I', zlib.crc32(compressed))
            size = struct.pack('I', len(compressed))
            
            # Write to file
            with open(filepath, 'wb') as f:
                f.write(b'SAVE')  # Magic number
                f.write(version)
                f.write(checksum)
                f.write(size)
                f.write(compressed)
            
            print(f"Binary save complete: {len(compressed)} bytes")
            return True
            
        except Exception as e:
            print(f"Binary save failed: {e}")
            return False
    
    def load_binary(self, slot: int) -> Optional[SaveData]:
        """Load game data from compressed binary"""
        filename = f"savegame_{slot}.dat"
        filepath = os.path.join(self.save_directory, filename)
        
        if not os.path.exists(filepath):
            return None
        
        try:
            with open(filepath, 'rb') as f:
                # Check magic number
                magic = f.read(4)
                if magic != b'SAVE':
                    print("Invalid save file format")
                    return None
                
                # Read header
                version = struct.unpack('I', f.read(4))[0]
                checksum = struct.unpack('I', f.read(4))[0]
                size = struct.unpack('I', f.read(4))[0]
                
                # Read compressed data
                compressed = f.read(size)
                
                # Verify checksum
                if zlib.crc32(compressed) != checksum:
                    print("Save file corrupted")
                    return None
                
                # Decompress
                binary_data = zlib.decompress(compressed)
                
                # Deserialize
                data = pickle.loads(binary_data)
                
                return SaveData(**data)
                
        except Exception as e:
            print(f"Binary load failed: {e}")
            return None

# Encrypted save system
from cryptography.fernet import Fernet

class EncryptedSaveManager(SaveManager):
    """Save system with encryption"""
    
    def __init__(self, save_directory: str = "saves"):
        super().__init__(save_directory)
        self.key = self.load_or_generate_key()
        self.cipher = Fernet(self.key)
    
    def load_or_generate_key(self) -> bytes:
        """Load or generate encryption key"""
        key_file = os.path.join(self.save_directory, ".key")
        
        if os.path.exists(key_file):
            with open(key_file, 'rb') as f:
                return f.read()
        else:
            key = Fernet.generate_key()
            with open(key_file, 'wb') as f:
                f.write(key)
            return key
    
    def save_encrypted(self, slot: int, save_data: SaveData) -> bool:
        """Save encrypted game data"""
        filename = f"savegame_{slot}.enc"
        filepath = os.path.join(self.save_directory, filename)
        
        try:
            # Serialize to JSON
            json_data = json.dumps(asdict(save_data))
            
            # Encrypt
            encrypted = self.cipher.encrypt(json_data.encode())
            
            # Save
            with open(filepath, 'wb') as f:
                f.write(encrypted)
            
            print(f"Encrypted save complete")
            return True
            
        except Exception as e:
            print(f"Encrypted save failed: {e}")
            return False
    
    def load_encrypted(self, slot: int) -> Optional[SaveData]:
        """Load encrypted game data"""
        filename = f"savegame_{slot}.enc"
        filepath = os.path.join(self.save_directory, filename)
        
        if not os.path.exists(filepath):
            return None
        
        try:
            with open(filepath, 'rb') as f:
                encrypted = f.read()
            
            # Decrypt
            decrypted = self.cipher.decrypt(encrypted)
            
            # Deserialize
            data = json.loads(decrypted.decode())
            
            return SaveData(**data)
            
        except Exception as e:
            print(f"Encrypted load failed: {e}")
            return None

# Cloud save system
class CloudSaveManager(SaveManager):
    """Cloud-based save system"""
    
    def __init__(self, save_directory: str = "saves", cloud_provider=None):
        super().__init__(save_directory)
        self.cloud_provider = cloud_provider  # AWS, Google Cloud, etc.
        self.sync_enabled = True
        self.last_sync = time.time()
    
    def sync_saves(self):
        """Sync local saves with cloud"""
        if not self.sync_enabled:
            return
        
        try:
            # Get local saves
            local_saves = self.list_saves()
            
            # Get cloud saves (pseudo-code)
            # cloud_saves = self.cloud_provider.list_saves()
            
            # Compare and sync
            for save in local_saves:
                # Upload newer local saves
                # self.cloud_provider.upload(save)
                pass
            
            # Download newer cloud saves
            # for cloud_save in cloud_saves:
            #     if cloud_save.newer_than_local():
            #         self.download_save(cloud_save)
            
            self.last_sync = time.time()
            print("Cloud sync complete")
            
        except Exception as e:
            print(f"Cloud sync failed: {e}")

# Save versioning and migration
class SaveMigration:
    """Handles save file version migrations"""
    
    @staticmethod
    def migrate(save_data: dict, from_version: str, to_version: str) -> dict:
        """Migrate save data between versions"""
        migrations = {
            ("1.0.0", "1.1.0"): SaveMigration.migrate_1_0_to_1_1,
            ("1.1.0", "2.0.0"): SaveMigration.migrate_1_1_to_2_0,
        }
        
        key = (from_version, to_version)
        if key in migrations:
            return migrations[key](save_data)
        
        # Handle multi-step migrations
        # ... migration chain logic ...
        
        return save_data
    
    @staticmethod
    def migrate_1_0_to_1_1(save_data: dict) -> dict:
        """Migrate from version 1.0.0 to 1.1.0"""
        # Add new fields with defaults
        save_data['new_feature'] = False
        save_data['version'] = "1.1.0"
        return save_data
    
    @staticmethod
    def migrate_1_1_to_2_0(save_data: dict) -> dict:
        """Migrate from version 1.1.0 to 2.0.0"""
        # Restructure data
        save_data['player'] = {
            'name': save_data.pop('player_name', 'Player'),
            'level': save_data.pop('player_level', 1),
            'health': save_data.pop('player_health', 100)
        }
        save_data['version'] = "2.0.0"
        return save_data</code></pre>

    <h2>Save System Integration</h2>
    
    <pre class="language-python"><code>import pygame

class GameWithSaveSystem:
    """Game with integrated save/load system"""
    def __init__(self):
        pygame.init()
        self.screen = pygame.display.set_mode((800, 600))
        pygame.display.set_caption("Game with Save System")
        self.clock = pygame.time.Clock()
        self.running = True
        
        # Initialize save manager
        self.save_manager = SaveManager()
        
        # Game state
        self.player = Player()
        self.enemies = []
        self.items = []
        self.score = 0
        self.current_level = 1
        self.play_time = 0
        
        # Load last save on startup
        self.load_last_save()
    
    def load_last_save(self):
        """Load most recent save on startup"""
        saves = self.save_manager.list_saves()
        if saves:
            # Load most recent save
            most_recent = max(saves, key=lambda x: x['timestamp'])
            save_data = self.save_manager.load_game(most_recent['slot'])
            if save_data:
                self.restore_game_state(save_data)
    
    def collect_game_state(self) -> SaveData:
        """Collect current game state for saving"""
        save_data = SaveData()
        
        # Player data
        save_data.player_name = self.player.name
        save_data.player_level = self.player.level
        save_data.player_health = self.player.health
        save_data.player_position = (self.player.x, self.player.y)
        save_data.player_inventory = self.player.inventory.copy()
        
        # Game progress
        save_data.current_level = self.current_level
        save_data.score = self.score
        save_data.play_time = self.play_time
        
        # World state
        save_data.enemies = [enemy.to_dict() for enemy in self.enemies]
        save_data.items = [item.to_dict() for item in self.items]
        
        return save_data
    
    def restore_game_state(self, save_data: SaveData):
        """Restore game state from save data"""
        # Player data
        self.player.name = save_data.player_name
        self.player.level = save_data.player_level
        self.player.health = save_data.player_health
        self.player.x, self.player.y = save_data.player_position
        self.player.inventory = save_data.player_inventory.copy()
        
        # Game progress
        self.current_level = save_data.current_level
        self.score = save_data.score
        self.play_time = save_data.play_time
        
        # World state
        self.enemies = [Enemy.from_dict(e) for e in save_data.enemies]
        self.items = [Item.from_dict(i) for i in save_data.items]
        
        print("Game state restored")
    
    def handle_input(self):
        """Handle input including save/load keys"""
        keys = pygame.key.get_pressed()
        
        # Quick save (F5)
        if keys[pygame.K_F5]:
            save_data = self.collect_game_state()
            self.save_manager.quick_save()
        
        # Quick load (F9)
        if keys[pygame.K_F9]:
            save_data = self.save_manager.quick_load()
            if save_data:
                self.restore_game_state(save_data)
        
        # Save slots (Ctrl+1-9)
        if keys[pygame.K_LCTRL]:
            for i in range(1, 10):
                if keys[pygame.K_0 + i]:
                    save_data = self.collect_game_state()
                    self.save_manager.save_game(i, save_data)
        
        # Load slots (Alt+1-9)
        if keys[pygame.K_LALT]:
            for i in range(1, 10):
                if keys[pygame.K_0 + i]:
                    save_data = self.save_manager.load_game(i)
                    if save_data:
                        self.restore_game_state(save_data)
    
    def update(self, dt):
        """Update game and check for auto-save"""
        # Update play time
        self.play_time += dt
        
        # Check auto-save
        if self.save_manager.auto_save():
            save_data = self.collect_game_state()
            self.save_manager.current_save_data = save_data
            print("Auto-saved")
        
        # Update game
        self.player.update(dt)
        for enemy in self.enemies:
            enemy.update(dt)
    
    def draw_save_menu(self):
        """Draw save/load menu overlay"""
        # Draw transparent background
        overlay = pygame.Surface((800, 600))
        overlay.set_alpha(200)
        overlay.fill((0, 0, 0))
        self.screen.blit(overlay, (0, 0))
        
        # Draw save slots
        font = pygame.font.Font(None, 36)
        saves = self.save_manager.list_saves()
        
        y = 100
        for i in range(1, 4):
            # Find save for this slot
            save = next((s for s in saves if s['slot'] == i), None)
            
            if save:
                # Format save info
                timestamp = datetime.fromtimestamp(save['timestamp'])
                text = f"Slot {i}: Level {save['level']} - Score {save['score']} - {timestamp.strftime('%Y-%m-%d %H:%M')}"
            else:
                text = f"Slot {i}: Empty"
            
            rendered = font.render(text, True, (255, 255, 255))
            self.screen.blit(rendered, (50, y))
            y += 50
    
    def run(self):
        """Main game loop"""
        dt = 0
        
        while self.running:
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    # Save before quitting
                    save_data = self.collect_game_state()
                    self.save_manager.save_game(99, save_data)  # Exit save
                    self.running = False
            
            self.handle_input()
            self.update(dt)
            
            # Draw game
            self.screen.fill((20, 20, 30))
            self.player.draw(self.screen)
            
            # Draw UI
            self.draw_ui()
            
            pygame.display.flip()
            dt = self.clock.tick(60) / 1000.0

# Example classes for game objects
class Player:
    def __init__(self):
        self.name = "Player"
        self.x = 400
        self.y = 300
        self.health = 100
        self.level = 1
        self.inventory = []
    
    def to_dict(self):
        return {
            'name': self.name,
            'x': self.x,
            'y': self.y,
            'health': self.health,
            'level': self.level,
            'inventory': self.inventory
        }
    
    @staticmethod
    def from_dict(data):
        player = Player()
        player.name = data['name']
        player.x = data['x']
        player.y = data['y']
        player.health = data['health']
        player.level = data['level']
        player.inventory = data['inventory']
        return player</code></pre>

    <h2>Best Practices</h2>
    
    <div style="background-color: #fff3e0; padding: 20px; border-radius: 10px; margin: 20px 0;">
        <h3>⚡ Save System Tips</h3>
        <ul>
            <li><strong>Atomic Saves:</strong> Write to temp file first, then rename</li>
            <li><strong>Backup Saves:</strong> Keep multiple backup copies</li>
            <li><strong>Version Control:</strong> Include version numbers for migration</li>
            <li><strong>Data Validation:</strong> Always validate loaded data</li>
            <li><strong>Compression:</strong> Compress large save files</li>
            <li><strong>Encryption:</strong> Protect against save editing if needed</li>
            <li><strong>Auto-Save:</strong> Save periodically and at checkpoints</li>
            <li><strong>Save Thumbnails:</strong> Include screenshots for visual reference</li>
        </ul>
    </div>

    <h2>Key Takeaways</h2>
    
    <div style="background-color: #f0f8ff; padding: 20px; border-radius: 10px; margin: 20px 0;">
        <ul>
            <li>💾 Save systems preserve player progress and game state</li>
            <li>📝 Serialization converts game objects to storable formats</li>
            <li>🔄 Deserialization restores game state from saved data</li>
            <li>🗂️ Multiple save slots let players manage different playthroughs</li>
            <li>⚡ Quick save/load provides convenient state management</li>
            <li>☁️ Cloud saves enable cross-device play</li>
            <li>🔒 Encryption protects save data integrity</li>
            <li>📊 Save versioning handles game updates gracefully</li>
        </ul>
    </div>

    <h2>What's Next?</h2>
    
    <p>Congratulations! You've completed Section 1: Game Architecture! Next, we'll move on to Section 2: Networking and Multiplayer, where you'll learn to create connected gaming experiences!</p>

    <!-- Lesson Navigation -->
    <nav class="lesson-nav" aria-label="Lesson navigation">
        <a href="architecture_event_systems.html" class="prev-lesson" aria-label="Previous lesson: Event Systems">Previous Lesson: Event Systems</a>
        <a href="networking_basics.html" class="next-lesson" aria-label="Next section: Networking Basics">Next Section: Networking & Multiplayer</a>
    </nav>
    
    </main>
    <script src="/js/course-enhancements.js" defer></script>
</body>
</html>