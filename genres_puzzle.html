<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Create puzzle game mechanics. Learn match-3 systems, physics puzzles, logic gates, pattern recognition, and procedural puzzle generation.">
    <title>Puzzle Game Logic - Different Game Genres</title>
    <link rel="stylesheet" href="styles/main.css">
    <link rel="stylesheet" href="styles/enhanced.css">
    <link rel="icon" href="favicon.png">
    <script type="module">
      import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
      mermaid.initialize({ startOnLoad: true });
    </script>
    <style>
        .game-controls button {
            margin: 2px;
            padding: 8px 12px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s;
        }
        .game-controls button:hover {
            background-color: #45a049;
            transform: translateY(-2px);
        }
        .game-controls button:active {
            transform: translateY(0);
        }
        .game-controls button.active {
            background-color: #2196F3;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }
        .game-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
            margin: 10px auto;
            padding: 15px;
            background: rgba(0,0,0,0.5);
            border-radius: 10px;
            max-width: 800px;
        }
        .stat-item {
            padding: 10px;
            background: rgba(255,255,255,0.1);
            border-radius: 5px;
            text-align: center;
            color: white;
        }
    </style>
</head>
<body>
    <!-- Skip to main content for accessibility -->
    <a href="#main-content" class="skip-to-main">Skip to main content</a>
    
    <!-- Progress indicator -->
    <div class="progress-indicator" role="progressbar" aria-label="Page scroll progress">
        <div class="progress-bar"></div>
    </div>
    
    <main id="main-content">
    <header role="banner">
        <h1>Puzzle Game Logic</h1>
        <div class="reading-time" aria-label="Estimated reading time">20 minute read</div>
    </header>
    
    <!-- Breadcrumb Navigation -->
    <nav class="breadcrumb" aria-label="Breadcrumb">
        <a href="index.html">Course Home</a>
        <span class="separator">‚Ä∫</span>
        <span class="current">Advanced Module - Section 3: Different Game Genres - Lesson 3</span>
    </nav>

    <h2>Building Engaging Puzzle Game Mechanics</h2>
    
    <div style="background-color: #f0f8ff; padding: 20px; border-radius: 10px; margin: 20px 0;">
        <p>Master puzzle game design! Create match-3 mechanics, sliding puzzles, physics-based challenges, pattern matching, and logic gates! üß©üíéüîÆ</p>
    </div>

    <h2>Understanding Puzzle Game Systems</h2>
    
    <div style="background-color: #fff5f5; padding: 20px; border-radius: 10px; margin: 20px 0;">
        <h3>üéØ Core Puzzle Mechanics</h3>
        <p>Great puzzle games combine simple rules with emergent complexity:</p>
        <ul>
            <li><strong>Match-3:</strong> Pattern matching and cascading combos</li>
            <li><strong>Sliding Puzzles:</strong> Spatial reasoning and planning</li>
            <li><strong>Physics Puzzles:</strong> Real-world mechanics and experimentation</li>
            <li><strong>Logic Puzzles:</strong> Deduction and systematic thinking</li>
            <li><strong>Pattern Memory:</strong> Observation and recall</li>
            <li><strong>Word Puzzles:</strong> Language and vocabulary</li>
        </ul>
    </div>

    <div class="mermaid">
    graph TD
        A["Puzzle Game Core"] --> B["Input System"]
        A --> C["Game Rules"]
        A --> D["Win Conditions"]
        A --> E["Feedback System"]
        
        B --> F["Click/Touch"]
        B --> G["Drag & Drop"]
        B --> H["Keyboard"]
        
        C --> I["Valid Moves"]
        C --> J["Constraints"]
        C --> K["Scoring"]
        
        D --> L["Clear Board"]
        D --> M["Target Score"]
        D --> N["Time Limit"]
        
        E --> O["Visual Effects"]
        E --> P["Sound Cues"]
        E --> Q["Progress Indicators"]
    </div>

    <h2>Interactive Multi-Puzzle Demo</h2>
    
    <div class="canvas-wrapper" style="text-align: center;">
        <canvas id="puzzleCanvas" width="800" height="600" style="border: 2px solid #333; background: #2c3e50; display: inline-block;"></canvas>
    </div>
    
    <div class="game-controls" style="text-align: center; margin-top: 10px;">
        <p>Experience different puzzle mechanics - Match gems, slide tiles, launch projectiles, and solve logic gates!</p>
        
        <!-- Puzzle Type Selector -->
        <div style="margin: 10px auto; padding: 10px; background-color: rgba(0,0,0,0.3); border-radius: 5px;">
            <h4 style="color: white;">Select Puzzle Type:</h4>
            <button id="btn-match3" class="active">üíé Match-3</button>
            <button id="btn-sliding">üî¢ Sliding</button>
            <button id="btn-physics">üéØ Physics</button>
            <button id="btn-pattern">üé® Pattern</button>
            <button id="btn-logic">‚ö° Logic Gates</button>
        </div>
        
        <!-- Game Controls -->
        <div style="margin: 10px auto; padding: 10px; background-color: rgba(0,0,0,0.3); border-radius: 5px; max-width: 800px;">
            <p style="color: white; margin: 5px;" id="controlsText">
                Match-3: Click to select, click adjacent gem to swap
            </p>
        </div>
        
        <!-- Game Actions -->
        <div style="margin: 10px auto;">
            <button onclick="puzzleGame.reset()">üîÑ Reset</button>
            <button onclick="puzzleGame.hint()">üí° Hint</button>
            <button onclick="puzzleGame.shuffle()">üîÄ Shuffle</button>
        </div>
        
        <!-- Game Stats -->
        <div class="game-stats">
            <div class="stat-item">
                üèÜ Score: <span id="score">0</span>
            </div>
            <div class="stat-item">
                üéØ Moves: <span id="moves">0</span>
            </div>
            <div class="stat-item">
                ‚è±Ô∏è Time: <span id="timer">0:00</span>
            </div>
            <div class="stat-item">
                ‚ö° Combo: <span id="combo">1x</span>
            </div>
        </div>
    </div>

    <script>
        // Puzzle Game System
        class PuzzleGame {
            constructor() {
                this.canvas = document.getElementById('puzzleCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.currentPuzzle = 'match3';
                this.score = 0;
                this.moves = 0;
                this.combo = 1;
                this.startTime = Date.now();
                
                this.puzzles = {
                    match3: new Match3Puzzle(this),
                    sliding: new SlidingPuzzle(this),
                    physics: new PhysicsPuzzle(this),
                    pattern: new PatternPuzzle(this),
                    logic: new LogicPuzzle(this)
                };
                
                this.init();
            }
            
            init() {
                // Set up event listeners
                this.canvas.addEventListener('click', (e) => this.handleClick(e));
                
                // Set up button listeners
                document.getElementById('btn-match3').addEventListener('click', () => this.switchPuzzle('match3'));
                document.getElementById('btn-sliding').addEventListener('click', () => this.switchPuzzle('sliding'));
                document.getElementById('btn-physics').addEventListener('click', () => this.switchPuzzle('physics'));
                document.getElementById('btn-pattern').addEventListener('click', () => this.switchPuzzle('pattern'));
                document.getElementById('btn-logic').addEventListener('click', () => this.switchPuzzle('logic'));
                
                // Start game loop
                this.gameLoop();
            }
            
            handleClick(e) {
                const rect = this.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                this.puzzles[this.currentPuzzle].handleClick(x, y);
            }
            
            switchPuzzle(type) {
                this.currentPuzzle = type;
                this.reset();
                
                // Update buttons
                document.querySelectorAll('.game-controls button').forEach(btn => {
                    btn.classList.remove('active');
                });
                document.getElementById(`btn-${type}`).classList.add('active');
                
                // Update instructions
                const instructions = {
                    match3: 'Match-3: Click to select, click adjacent gem to swap',
                    sliding: 'Sliding: Click tiles next to empty space to move',
                    physics: 'Physics: Click to launch projectile at targets',
                    pattern: 'Pattern: Watch the sequence, then repeat it',
                    logic: 'Logic: Toggle inputs to make output match target'
                };
                document.getElementById('controlsText').textContent = instructions[type];
            }
            
            reset() {
                this.puzzles[this.currentPuzzle].init();
                this.score = 0;
                this.moves = 0;
                this.combo = 1;
                this.startTime = Date.now();
            }
            
            hint() {
                this.puzzles[this.currentPuzzle].hint();
            }
            
            shuffle() {
                this.puzzles[this.currentPuzzle].shuffle();
            }
            
            updateStats() {
                document.getElementById('score').textContent = this.score;
                document.getElementById('moves').textContent = this.moves;
                document.getElementById('combo').textContent = this.combo + 'x';
                
                const elapsed = Math.floor((Date.now() - this.startTime) / 1000);
                const minutes = Math.floor(elapsed / 60);
                const seconds = elapsed % 60;
                document.getElementById('timer').textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
            }
            
            gameLoop() {
                // Clear canvas
                this.ctx.fillStyle = '#2c3e50';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Update and render current puzzle
                this.puzzles[this.currentPuzzle].update();
                this.puzzles[this.currentPuzzle].render();
                
                // Update UI
                this.updateStats();
                
                requestAnimationFrame(() => this.gameLoop());
            }
        }
        
        // Match-3 Puzzle
        class Match3Puzzle {
            constructor(game) {
                this.game = game;
                this.gridSize = 8;
                this.tileSize = 60;
                this.grid = [];
                this.selected = null;
                this.colors = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#96E6A1', '#FFEAA7', '#DDA0DD'];
                this.init();
            }
            
            init() {
                this.grid = [];
                for (let y = 0; y < this.gridSize; y++) {
                    this.grid[y] = [];
                    for (let x = 0; x < this.gridSize; x++) {
                        this.grid[y][x] = Math.floor(Math.random() * 6);
                    }
                }
                this.selected = null;
            }
            
            handleClick(mx, my) {
                const gridX = Math.floor((mx - 100) / this.tileSize);
                const gridY = Math.floor((my - 50) / this.tileSize);
                
                if (gridX >= 0 && gridX < this.gridSize && gridY >= 0 && gridY < this.gridSize) {
                    if (this.selected) {
                        const dx = Math.abs(gridX - this.selected.x);
                        const dy = Math.abs(gridY - this.selected.y);
                        
                        if ((dx === 1 && dy === 0) || (dx === 0 && dy === 1)) {
                            // Swap gems
                            const temp = this.grid[gridY][gridX];
                            this.grid[gridY][gridX] = this.grid[this.selected.y][this.selected.x];
                            this.grid[this.selected.y][this.selected.x] = temp;
                            this.game.moves++;
                            this.game.score += 10;
                        }
                        this.selected = null;
                    } else {
                        this.selected = { x: gridX, y: gridY };
                    }
                }
            }
            
            hint() {
                // Simple hint: highlight a random gem
                const x = Math.floor(Math.random() * this.gridSize);
                const y = Math.floor(Math.random() * this.gridSize);
                this.selected = { x, y };
                setTimeout(() => { this.selected = null; }, 1000);
            }
            
            shuffle() {
                this.init();
            }
            
            update() {
                // Animation updates would go here
            }
            
            render() {
                const ctx = this.game.ctx;
                
                // Draw grid background
                ctx.fillStyle = 'rgba(0,0,0,0.3)';
                ctx.fillRect(95, 45, this.gridSize * this.tileSize + 10, this.gridSize * this.tileSize + 10);
                
                // Draw gems
                for (let y = 0; y < this.gridSize; y++) {
                    for (let x = 0; x < this.gridSize; x++) {
                        const px = 100 + x * this.tileSize;
                        const py = 50 + y * this.tileSize;
                        
                        // Draw gem
                        ctx.fillStyle = this.colors[this.grid[y][x]];
                        ctx.beginPath();
                        ctx.arc(px + this.tileSize/2, py + this.tileSize/2, this.tileSize/2 - 5, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Draw highlight
                        ctx.fillStyle = 'rgba(255,255,255,0.3)';
                        ctx.beginPath();
                        ctx.arc(px + this.tileSize/3, py + this.tileSize/3, this.tileSize/4, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Draw selection
                        if (this.selected && this.selected.x === x && this.selected.y === y) {
                            ctx.strokeStyle = '#FFD700';
                            ctx.lineWidth = 3;
                            ctx.strokeRect(px, py, this.tileSize, this.tileSize);
                        }
                    }
                }
            }
        }
        
        // Sliding Puzzle
        class SlidingPuzzle {
            constructor(game) {
                this.game = game;
                this.size = 4;
                this.tileSize = 80;
                this.grid = [];
                this.emptyPos = { x: 3, y: 3 };
                this.init();
            }
            
            init() {
                // Create solved puzzle
                this.grid = [];
                let num = 1;
                for (let y = 0; y < this.size; y++) {
                    this.grid[y] = [];
                    for (let x = 0; x < this.size; x++) {
                        if (y === this.size - 1 && x === this.size - 1) {
                            this.grid[y][x] = 0;
                        } else {
                            this.grid[y][x] = num++;
                        }
                    }
                }
                
                this.emptyPos = { x: this.size - 1, y: this.size - 1 };
                
                // Shuffle with valid moves
                for (let i = 0; i < 100; i++) {
                    const dirs = [[0, 1], [0, -1], [1, 0], [-1, 0]];
                    const dir = dirs[Math.floor(Math.random() * 4)];
                    const newX = this.emptyPos.x + dir[0];
                    const newY = this.emptyPos.y + dir[1];
                    
                    if (newX >= 0 && newX < this.size && newY >= 0 && newY < this.size) {
                        this.grid[this.emptyPos.y][this.emptyPos.x] = this.grid[newY][newX];
                        this.grid[newY][newX] = 0;
                        this.emptyPos = { x: newX, y: newY };
                    }
                }
            }
            
            handleClick(mx, my) {
                const gridX = Math.floor((mx - 250) / this.tileSize);
                const gridY = Math.floor((my - 150) / this.tileSize);
                
                if (gridX >= 0 && gridX < this.size && gridY >= 0 && gridY < this.size) {
                    const dx = Math.abs(gridX - this.emptyPos.x);
                    const dy = Math.abs(gridY - this.emptyPos.y);
                    
                    if ((dx === 1 && dy === 0) || (dx === 0 && dy === 1)) {
                        this.grid[this.emptyPos.y][this.emptyPos.x] = this.grid[gridY][gridX];
                        this.grid[gridY][gridX] = 0;
                        this.emptyPos = { x: gridX, y: gridY };
                        this.game.moves++;
                        
                        if (this.checkWin()) {
                            this.game.score += 100;
                        }
                    }
                }
            }
            
            checkWin() {
                let expected = 1;
                for (let y = 0; y < this.size; y++) {
                    for (let x = 0; x < this.size; x++) {
                        if (y === this.size - 1 && x === this.size - 1) {
                            if (this.grid[y][x] !== 0) return false;
                        } else {
                            if (this.grid[y][x] !== expected++) return false;
                        }
                    }
                }
                return true;
            }
            
            hint() {
                // Flash tiles next to empty space
            }
            
            shuffle() {
                this.init();
            }
            
            update() {}
            
            render() {
                const ctx = this.game.ctx;
                const offsetX = 250;
                const offsetY = 150;
                
                // Background
                ctx.fillStyle = 'rgba(0,0,0,0.3)';
                ctx.fillRect(offsetX - 5, offsetY - 5, this.size * this.tileSize + 10, this.size * this.tileSize + 10);
                
                // Draw tiles
                for (let y = 0; y < this.size; y++) {
                    for (let x = 0; x < this.size; x++) {
                        const value = this.grid[y][x];
                        
                        if (value !== 0) {
                            const tileX = offsetX + x * this.tileSize;
                            const tileY = offsetY + y * this.tileSize;
                            
                            ctx.fillStyle = this.checkWin() ? '#4CAF50' : '#2196F3';
                            ctx.fillRect(tileX + 2, tileY + 2, this.tileSize - 4, this.tileSize - 4);
                            
                            ctx.strokeStyle = 'white';
                            ctx.lineWidth = 2;
                            ctx.strokeRect(tileX + 2, tileY + 2, this.tileSize - 4, this.tileSize - 4);
                            
                            ctx.fillStyle = 'white';
                            ctx.font = 'bold 36px Arial';
                            ctx.textAlign = 'center';
                            ctx.textBaseline = 'middle';
                            ctx.fillText(value.toString(), tileX + this.tileSize/2, tileY + this.tileSize/2);
                        }
                    }
                }
                
                if (this.checkWin()) {
                    ctx.fillStyle = '#4CAF50';
                    ctx.font = 'bold 48px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('SOLVED!', this.game.canvas.width/2, 100);
                }
            }
        }
        
        // Physics Puzzle
        class PhysicsPuzzle {
            constructor(game) {
                this.game = game;
                this.projectile = { x: 100, y: 400, vx: 0, vy: 0, launched: false };
                this.targets = [];
                this.init();
            }
            
            init() {
                this.projectile = { x: 100, y: 400, vx: 0, vy: 0, launched: false };
                this.targets = [];
                for (let i = 0; i < 3; i++) {
                    this.targets.push({
                        x: 500 + Math.random() * 200,
                        y: 200 + Math.random() * 200,
                        hit: false
                    });
                }
            }
            
            handleClick(mx, my) {
                if (!this.projectile.launched) {
                    const dx = mx - this.projectile.x;
                    const dy = my - this.projectile.y;
                    const angle = Math.atan2(dy, dx);
                    const power = Math.min(20, Math.sqrt(dx*dx + dy*dy) / 10);
                    
                    this.projectile.vx = Math.cos(angle) * power;
                    this.projectile.vy = Math.sin(angle) * power;
                    this.projectile.launched = true;
                    this.game.moves++;
                }
            }
            
            hint() {}
            shuffle() { this.init(); }
            
            update() {
                if (this.projectile.launched) {
                    this.projectile.x += this.projectile.vx;
                    this.projectile.y += this.projectile.vy;
                    this.projectile.vy += 0.5;
                    
                    for (const target of this.targets) {
                        if (!target.hit) {
                            const dx = this.projectile.x - target.x;
                            const dy = this.projectile.y - target.y;
                            if (Math.sqrt(dx*dx + dy*dy) < 30) {
                                target.hit = true;
                                this.game.score += 50;
                            }
                        }
                    }
                    
                    if (this.projectile.y > this.game.canvas.height) {
                        this.projectile = { x: 100, y: 400, vx: 0, vy: 0, launched: false };
                    }
                }
            }
            
            render() {
                const ctx = this.game.ctx;
                
                // Ground
                ctx.fillStyle = '#654321';
                ctx.fillRect(0, 450, this.game.canvas.width, 150);
                
                // Targets
                for (const target of this.targets) {
                    if (!target.hit) {
                        ctx.fillStyle = '#4ECDC4';
                        ctx.beginPath();
                        ctx.arc(target.x, target.y, 20, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
                
                // Projectile
                ctx.fillStyle = '#FF6B6B';
                ctx.beginPath();
                ctx.arc(this.projectile.x, this.projectile.y, 10, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        // Pattern Puzzle
        class PatternPuzzle {
            constructor(game) {
                this.game = game;
                this.sequence = [];
                this.playerSequence = [];
                this.showing = false;
                this.colors = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#96E6A1'];
                this.init();
            }
            
            init() {
                this.sequence = [Math.floor(Math.random() * 4)];
                this.playerSequence = [];
                this.showSequence();
            }
            
            showSequence() {
                this.showing = true;
                setTimeout(() => { this.showing = false; }, 1000);
            }
            
            handleClick(mx, my) {
                if (!this.showing) {
                    const buttonSize = 100;
                    const startX = 300;
                    const startY = 200;
                    
                    for (let i = 0; i < 4; i++) {
                        const row = Math.floor(i / 2);
                        const col = i % 2;
                        const bx = startX + col * (buttonSize + 20);
                        const by = startY + row * (buttonSize + 20);
                        
                        if (mx >= bx && mx <= bx + buttonSize && my >= by && my <= by + buttonSize) {
                            this.playerSequence.push(i);
                            this.game.moves++;
                            
                            const idx = this.playerSequence.length - 1;
                            if (this.playerSequence[idx] === this.sequence[idx]) {
                                if (this.playerSequence.length === this.sequence.length) {
                                    this.game.score += 25 * this.sequence.length;
                                    this.sequence.push(Math.floor(Math.random() * 4));
                                    this.playerSequence = [];
                                    setTimeout(() => this.showSequence(), 500);
                                }
                            } else {
                                this.init();
                            }
                        }
                    }
                }
            }
            
            hint() {}
            shuffle() { this.init(); }
            update() {}
            
            render() {
                const ctx = this.game.ctx;
                const buttonSize = 100;
                const startX = 300;
                const startY = 200;
                
                for (let i = 0; i < 4; i++) {
                    const row = Math.floor(i / 2);
                    const col = i % 2;
                    const bx = startX + col * (buttonSize + 20);
                    const by = startY + row * (buttonSize + 20);
                    
                    if (this.showing && this.sequence[0] === i) {
                        ctx.fillStyle = this.colors[i];
                    } else {
                        ctx.fillStyle = this.colors[i] + '80';
                    }
                    
                    ctx.fillRect(bx, by, buttonSize, buttonSize);
                    ctx.strokeStyle = 'white';
                    ctx.strokeRect(bx, by, buttonSize, buttonSize);
                }
                
                ctx.fillStyle = 'white';
                ctx.font = '24px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(this.showing ? 'WATCH!' : 'REPEAT!', this.game.canvas.width/2, 150);
                ctx.fillText(`Level: ${this.sequence.length}`, this.game.canvas.width/2, 400);
            }
        }
        
        // Logic Puzzle
        class LogicPuzzle {
            constructor(game) {
                this.game = game;
                this.inputs = [false, false, false];
                this.init();
            }
            
            init() {
                this.inputs = [false, false, false];
            }
            
            handleClick(mx, my) {
                for (let i = 0; i < 3; i++) {
                    const ix = 150;
                    const iy = 200 + i * 80;
                    
                    if (Math.abs(mx - ix) < 30 && Math.abs(my - iy) < 30) {
                        this.inputs[i] = !this.inputs[i];
                        this.game.moves++;
                        
                        if (this.inputs[0] && this.inputs[1]) {
                            this.game.score += 50;
                        }
                    }
                }
            }
            
            hint() {}
            shuffle() { this.init(); }
            update() {}
            
            render() {
                const ctx = this.game.ctx;
                
                for (let i = 0; i < 3; i++) {
                    const ix = 150;
                    const iy = 200 + i * 80;
                    
                    ctx.fillStyle = this.inputs[i] ? '#4CAF50' : '#333';
                    ctx.beginPath();
                    ctx.arc(ix, iy, 20, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.fillStyle = 'white';
                    ctx.font = '16px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(['A', 'B', 'C'][i], ix, iy + 5);
                }
                
                ctx.fillStyle = '#2196F3';
                ctx.fillRect(300, 250, 80, 60);
                ctx.fillStyle = 'white';
                ctx.font = '20px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('AND', 340, 285);
                
                const output = this.inputs[0] && this.inputs[1];
                ctx.fillStyle = output ? '#4CAF50' : '#333';
                ctx.beginPath();
                ctx.arc(500, 280, 25, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = 'white';
                ctx.font = '20px Arial';
                ctx.fillText('Make the output GREEN!', this.game.canvas.width/2, 100);
            }
        }
        
        // Initialize the game
        const puzzleGame = new PuzzleGame();
    </script>

    <h2>Core Puzzle Types Explained</h2>
    
    <div style="background-color: #f9f9f9; padding: 20px; border-radius: 10px; margin: 20px 0;">
        <h3>üéÆ Essential Puzzle Mechanics</h3>
        
        <h4>1. Match-3 Mechanics</h4>
        <ul>
            <li>Grid-based gem/tile matching</li>
            <li>Gravity and cascading effects</li>
            <li>Special tiles and power-ups</li>
            <li>Combo multipliers</li>
        </ul>
        
        <h4>2. Sliding Puzzles</h4>
        <ul>
            <li>15-puzzle and variants</li>
            <li>Optimal move counting</li>
            <li>Solvability detection</li>
            <li>A* pathfinding for hints</li>
        </ul>
        
        <h4>3. Physics Puzzles</h4>
        <ul>
            <li>Projectile mechanics</li>
            <li>Collision detection</li>
            <li>Force and momentum</li>
            <li>Environmental interactions</li>
        </ul>
        
        <h4>4. Pattern Matching</h4>
        <ul>
            <li>Sequence memorization</li>
            <li>Progressive difficulty</li>
            <li>Visual and audio cues</li>
            <li>Time-based challenges</li>
        </ul>
        
        <h4>5. Logic Gates</h4>
        <ul>
            <li>Boolean operations</li>
            <li>Circuit simulation</li>
            <li>Truth tables</li>
            <li>Complex gate combinations</li>
        </ul>
    </div>

    <h2>Puzzle Game Implementation in Python</h2>
    
    <div style="background-color: #f0fff0; padding: 20px; border-radius: 10px; margin: 20px 0;">
        <h3>üêç Complete Python Implementation</h3>
        <p>For the full Python implementation with Pygame including all puzzle types, advanced features, and procedural generation, <a href="/genres_puzzle_python.html">Python code</a>.</p>
        
        <h4>Key Implementation Features:</h4>
        <ul>
            <li>Object-oriented puzzle system</li>
            <li>Modular game states</li>
            <li>Animation framework</li>
            <li>Score and combo system</li>
            <li>Level progression</li>
            <li>Save/load functionality</li>
            <li>Procedural puzzle generation</li>
            <li>Hint and auto-solve algorithms</li>
        </ul>
    </div>

    <h2>Best Practices</h2>
    
    <div style="background-color: #fff3e0; padding: 20px; border-radius: 10px; margin: 20px 0;">
        <h3>‚ú® Puzzle Game Best Practices</h3>
        <ul>
            <li><strong>Clear Rules:</strong> Players should understand mechanics immediately</li>
            <li><strong>Progressive Difficulty:</strong> Smooth learning curve</li>
            <li><strong>Visual Feedback:</strong> Immediate response to actions</li>
            <li><strong>No Dead Ends:</strong> Always have possible moves</li>
            <li><strong>Hint Systems:</strong> Help stuck players</li>
            <li><strong>Satisfying Effects:</strong> Reward successful moves</li>
            <li><strong>Multiple Solutions:</strong> Allow creative problem solving</li>
            <li><strong>Undo Feature:</strong> Reduce frustration</li>
        </ul>
    </div>

    <h2>Key Takeaways</h2>
    
    <div style="background-color: #f0f8ff; padding: 20px; border-radius: 10px; margin: 20px 0;">
        <ul>
            <li>üíé Match-3 mechanics create addictive gameplay</li>
            <li>üß© Sliding puzzles test spatial reasoning</li>
            <li>‚öôÔ∏è Physics puzzles reward experimentation</li>
            <li>üîå Logic puzzles teach systematic thinking</li>
            <li>üé® Pattern games improve memory</li>
            <li>üìà Difficulty progression keeps players engaged</li>
            <li>‚ú® Polish and juice make puzzles satisfying</li>
            <li>üîÑ Procedural generation adds replayability</li>
        </ul>
    </div>

    <h2>What's Next?</h2>
    
    <p>Now that you've mastered puzzle game logic, next we'll explore racing game physics!</p>

    <!-- Lesson Navigation -->
    <nav class="lesson-nav" aria-label="Lesson navigation">
        <a href="genres_strategy.html" class="prev-lesson">Previous: Strategy Game Mechanics</a>
        <a href="genres_racing.html" class="next-lesson">Next: Racing Game Physics</a>
    </nav>
    
    </main>
</body>
</html>
