<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Complete Python implementation of strategy game mechanics including resource management, unit control, and AI opponents.">
    <title>Strategy Game Python Implementation - Different Game Genres</title>
    <link rel="stylesheet" href="/styles/main.css">
    <link rel="stylesheet" href="/styles/enhanced.css">
    <link rel="icon" href="/favicon.png">
</head>
<body>
    <!-- Skip to main content for accessibility -->
    <a href="#main-content" class="skip-to-main">Skip to main content</a>
    
    <main id="main-content">
    <header role="banner">
        <h1>Strategy Game Mechanics - Python Implementation</h1>
    </header>
    
    <!-- Breadcrumb Navigation -->
    <nav class="breadcrumb" aria-label="Breadcrumb">
        <a href="index.html">Course Home</a>
        <span class="separator">›</span>
        <a href="genres_strategy.html">Strategy Game Mechanics</a>
        <span class="separator">›</span>
        <span class="current">Python Implementation</span>
    </nav>

    <h2>Complete Strategy Game Implementation in Python</h2>
    
    <div style="background-color: #f0f8ff; padding: 20px; border-radius: 10px; margin: 20px 0;">
        <p>This is the complete Python/Pygame implementation of a strategy game with all core mechanics including resource management, unit control, pathfinding, base building, and AI opponents.</p>
    </div>

    <h3>Full Strategy Game Code</h3>
    
    <pre class="language-python"><code>import pygame
import random
import math
import heapq
from enum import Enum
from typing import List, Tuple, Optional, Dict
from dataclasses import dataclass

class UnitType(Enum):
    WORKER = "worker"
    SOLDIER = "soldier"
    ARCHER = "archer"
    CAVALRY = "cavalry"
    SIEGE = "siege"

class BuildingType(Enum):
    BASE = "base"
    BARRACKS = "barracks"
    MINE = "mine"
    FARM = "farm"
    TOWER = "tower"
    WALL = "wall"

@dataclass
class Resources:
    gold: int = 0
    food: int = 0
    wood: int = 0
    
    def can_afford(self, cost: 'Resources') -> bool:
        return (self.gold >= cost.gold and 
                self.food >= cost.food and 
                self.wood >= cost.wood)
    
    def subtract(self, cost: 'Resources'):
        self.gold -= cost.gold
        self.food -= cost.food
        self.wood -= cost.wood
    
    def add(self, income: 'Resources'):
        self.gold += income.gold
        self.food += income.food
        self.wood += income.wood

class Unit:
    """Strategy game unit"""
    
    def __init__(self, unit_type: UnitType, x: int, y: int, faction: str):
        self.type = unit_type
        self.x = x
        self.y = y
        self.faction = faction
        self.selected = False
        
        # Stats based on type
        stats = {
            UnitType.WORKER: {
                'hp': 50, 'attack': 5, 'defense': 0,
                'speed': 1.5, 'range': 1, 'sight': 5
            },
            UnitType.SOLDIER: {
                'hp': 100, 'attack': 15, 'defense': 5,
                'speed': 1, 'range': 1, 'sight': 6
            },
            UnitType.ARCHER: {
                'hp': 60, 'attack': 12, 'defense': 2,
                'speed': 1.2, 'range': 5, 'sight': 8
            },
            UnitType.CAVALRY: {
                'hp': 120, 'attack': 20, 'defense': 3,
                'speed': 2, 'range': 1, 'sight': 7
            },
            UnitType.SIEGE: {
                'hp': 200, 'attack': 50, 'defense': 0,
                'speed': 0.5, 'range': 6, 'sight': 5
            }
        }
        
        unit_stats = stats[unit_type]
        self.max_hp = unit_stats['hp']
        self.hp = self.max_hp
        self.attack = unit_stats['attack']
        self.defense = unit_stats['defense']
        self.speed = unit_stats['speed']
        self.range = unit_stats['range']
        self.sight = unit_stats['sight']
        
        # Movement
        self.target_x = x
        self.target_y = y
        self.path = []
        self.moving = False
        
        # Combat
        self.target = None
        self.cooldown = 0
        
        # Worker specific
        self.carrying = None
        self.gathering_from = None

class Building:
    """Strategy game building"""
    
    def __init__(self, building_type: BuildingType, x: int, y: int, faction: str):
        self.type = building_type
        self.x = x
        self.y = y
        self.faction = faction
        self.selected = False
        
        # Stats based on type
        stats = {
            BuildingType.BASE: {
                'hp': 1000, 'size': 3, 'sight': 10,
                'produces': [UnitType.WORKER]
            },
            BuildingType.BARRACKS: {
                'hp': 600, 'size': 2, 'sight': 5,
                'produces': [UnitType.SOLDIER, UnitType.ARCHER, UnitType.CAVALRY]
            },
            BuildingType.MINE: {
                'hp': 500, 'size': 2, 'sight': 3,
                'generates': {'gold': 10}
            },
            BuildingType.FARM: {
                'hp': 400, 'size': 2, 'sight': 3,
                'generates': {'food': 8}
            },
            BuildingType.TOWER: {
                'hp': 800, 'size': 1, 'sight': 8,
                'attack': 30, 'range': 8
            },
            BuildingType.WALL: {
                'hp': 300, 'size': 1, 'sight': 1
            }
        }
        
        building_stats = stats[building_type]
        self.max_hp = building_stats['hp']
        self.hp = self.max_hp
        self.size = building_stats['size']
        self.sight = building_stats['sight']
        
        self.produces = building_stats.get('produces', [])
        self.generates = building_stats.get('generates', {})
        self.attack = building_stats.get('attack', 0)
        self.range = building_stats.get('range', 0)
        
        # Production
        self.production_queue = []
        self.production_progress = 0
        
        # Combat
        self.target = None
        self.cooldown = 0
        
        # Construction
        self.construction_progress = 100  # Starts complete
        self.is_complete = True

class Map:
    """Game map with terrain and fog of war"""
    
    def __init__(self, width: int, height: int):
        self.width = width
        self.height = height
        self.tiles = []
        self.fog = []
        
        self.generate()
    
    def generate(self):
        """Generate random terrain"""
        for y in range(self.height):
            row = []
            fog_row = []
            for x in range(self.width):
                terrain = 'grass'
                
                # Add terrain variety
                if random.random() < 0.15:
                    terrain = 'forest'
                elif random.random() < 0.05:
                    terrain = 'mountain'
                elif random.random() < 0.03:
                    terrain = 'water'
                
                # Resources
                resource = None
                if terrain == 'grass' and random.random() < 0.05:
                    resource = random.choice(['gold', 'food', 'wood'])
                
                row.append({
                    'terrain': terrain,
                    'resource': resource,
                    'occupied': False
                })
                
                fog_row.append(False)  # Not explored
            
            self.tiles.append(row)
            self.fog.append(fog_row)
    
    def is_passable(self, x: int, y: int) -> bool:
        """Check if tile is passable"""
        if not self.in_bounds(x, y):
            return False
        
        tile = self.tiles[y][x]
        return (tile['terrain'] != 'water' and 
                tile['terrain'] != 'mountain' and
                not tile['occupied'])
    
    def in_bounds(self, x: int, y: int) -> bool:
        """Check if coordinates are in map bounds"""
        return 0 <= x < self.width and 0 <= y < self.height
    
    def reveal(self, x: int, y: int, radius: int):
        """Reveal fog of war around position"""
        for dy in range(-radius, radius + 1):
            for dx in range(-radius, radius + 1):
                nx, ny = x + dx, y + dy
                if self.in_bounds(nx, ny):
                    dist = math.sqrt(dx*dx + dy*dy)
                    if dist <= radius:
                        self.fog[ny][nx] = True

class Pathfinding:
    """A* pathfinding for units"""
    
    @staticmethod
    def find_path(start: Tuple[int, int], goal: Tuple[int, int], 
                  game_map: Map) -> List[Tuple[int, int]]:
        """Find path using A* algorithm"""
        
        def heuristic(a, b):
            return abs(a[0] - b[0]) + abs(a[1] - b[1])
        
        open_set = [(0, start)]
        came_from = {}
        g_score = {start: 0}
        f_score = {start: heuristic(start, goal)}
        
        while open_set:
            current = heapq.heappop(open_set)[1]
            
            if current == goal:
                # Reconstruct path
                path = []
                while current in came_from:
                    path.append(current)
                    current = came_from[current]
                return list(reversed(path))
            
            for dx, dy in [(0, 1), (1, 0), (0, -1), (-1, 0),
                          (1, 1), (-1, 1), (1, -1), (-1, -1)]:
                neighbor = (current[0] + dx, current[1] + dy)
                
                if not game_map.is_passable(neighbor[0], neighbor[1]):
                    continue
                
                tentative_g = g_score[current] + 1
                
                if neighbor not in g_score or tentative_g < g_score[neighbor]:
                    came_from[neighbor] = current
                    g_score[neighbor] = tentative_g
                    f_score[neighbor] = tentative_g + heuristic(neighbor, goal)
                    heapq.heappush(open_set, (f_score[neighbor], neighbor))
        
        return []  # No path found

class AIController:
    """AI opponent controller"""
    
    def __init__(self, faction: str, difficulty: str = 'normal'):
        self.faction = faction
        self.difficulty = difficulty
        self.action_timer = 0
        self.strategy = 'balanced'  # balanced, aggressive, defensive, economic
        self.build_order = ['worker', 'barracks', 'soldier', 'mine', 'worker', 'farm']
        self.current_build_index = 0
    
    def update(self, game_state: 'StrategyGame', dt: float):
        """Update AI decisions"""
        self.action_timer += dt
        
        # Make decisions at different rates based on difficulty
        decision_rate = {'easy': 5, 'normal': 3, 'hard': 2}[self.difficulty]
        
        if self.action_timer > decision_rate:
            self.action_timer = 0
            self.make_strategic_decision(game_state)
    
    def make_strategic_decision(self, game_state: 'StrategyGame'):
        """Make high-level strategic decisions"""
        my_units = [u for u in game_state.units if u.faction == self.faction]
        my_buildings = [b for b in game_state.buildings if b.faction == self.faction]
        enemy_units = [u for u in game_state.units if u.faction != self.faction]
        enemy_buildings = [b for b in game_state.buildings if b.faction != self.faction]
        
        # Assess situation
        military_strength = sum(1 for u in my_units if u.type != UnitType.WORKER)
        worker_count = sum(1 for u in my_units if u.type == UnitType.WORKER)
        
        # Decide strategy
        if military_strength < 3:
            self.strategy = 'defensive'
        elif worker_count < 5:
            self.strategy = 'economic'
        elif military_strength > 10:
            self.strategy = 'aggressive'
        else:
            self.strategy = 'balanced'
        
        # Execute strategy
        if self.strategy == 'aggressive':
            self.execute_attack(my_units, enemy_buildings + enemy_units)
        elif self.strategy == 'defensive':
            self.build_defenses(game_state, my_buildings)
        elif self.strategy == 'economic':
            self.expand_economy(game_state, my_buildings, my_units)
        else:
            self.balanced_approach(game_state, my_units, my_buildings)
    
    def execute_attack(self, my_units: List[Unit], targets: List):
        """Command units to attack"""
        if not targets:
            return
        
        # Find closest target
        for unit in my_units:
            if unit.type != UnitType.WORKER and not unit.target:
                closest_target = min(targets, 
                                   key=lambda t: math.sqrt((t.x - unit.x)**2 + (t.y - unit.y)**2))
                unit.target = closest_target
    
    def build_defenses(self, game_state: 'StrategyGame', my_buildings: List[Building]):
        """Build defensive structures"""
        for building in my_buildings:
            if building.type == BuildingType.BASE:
                # Build towers around base
                positions = [(building.x - 2, building.y), 
                           (building.x + building.size + 1, building.y),
                           (building.x, building.y - 2),
                           (building.x, building.y + building.size + 1)]
                
                for pos in positions:
                    if game_state.build_structure(BuildingType.TOWER, pos[0], pos[1]):
                        break
    
    def expand_economy(self, game_state: 'StrategyGame', my_buildings: List[Building], 
                       my_units: List[Unit]):
        """Focus on economic growth"""
        # Train more workers
        for building in my_buildings:
            if building.type == BuildingType.BASE and not building.production_queue:
                game_state.train_unit(UnitType.WORKER, building)
        
        # Build resource buildings
        if len([b for b in my_buildings if b.type == BuildingType.MINE]) < 2:
            # Find good location for mine
            for building in my_buildings:
                if building.type == BuildingType.BASE:
                    x, y = building.x + building.size + 2, building.y
                    game_state.build_structure(BuildingType.MINE, x, y)
                    break
    
    def balanced_approach(self, game_state: 'StrategyGame', my_units: List[Unit], 
                         my_buildings: List[Building]):
        """Balanced strategy"""
        # Train units
        for building in my_buildings:
            if building.type == BuildingType.BARRACKS and not building.production_queue:
                unit_types = [UnitType.SOLDIER, UnitType.ARCHER, UnitType.CAVALRY]
                game_state.train_unit(random.choice(unit_types), building)
        
        # Build structures
        if len(my_buildings) < 5:
            building_types = [BuildingType.BARRACKS, BuildingType.MINE, BuildingType.FARM]
            for building in my_buildings:
                if building.type == BuildingType.BASE:
                    x = building.x + random.randint(-5, 5)
                    y = building.y + random.randint(-5, 5)
                    game_state.build_structure(random.choice(building_types), x, y)
                    break

class StrategyGame:
    """Main strategy game class"""
    
    def __init__(self, screen_width: int = 800, screen_height: int = 600):
        pygame.init()
        self.screen = pygame.display.set_mode((screen_width, screen_height))
        pygame.display.set_caption("Strategy Game")
        self.clock = pygame.time.Clock()
        
        # Game state
        self.resources = Resources(gold=500, food=200, wood=100)
        self.map = Map(50, 40)
        self.camera_x = 0
        self.camera_y = 0
        
        # Entities
        self.units = []
        self.buildings = []
        self.selected = []
        
        # AI
        self.ai_controller = AIController('enemy', 'normal')
        
        # Costs
        self.unit_costs = {
            UnitType.WORKER: Resources(gold=50),
            UnitType.SOLDIER: Resources(gold=100, food=20),
            UnitType.ARCHER: Resources(gold=120, food=20),
            UnitType.CAVALRY: Resources(gold=200, food=50),
            UnitType.SIEGE: Resources(gold=300, wood=100)
        }
        
        self.building_costs = {
            BuildingType.BASE: Resources(gold=500, wood=200),
            BuildingType.BARRACKS: Resources(gold=300, wood=100),
            BuildingType.MINE: Resources(gold=200),
            BuildingType.FARM: Resources(gold=150, wood=50),
            BuildingType.TOWER: Resources(gold=250, wood=50),
            BuildingType.WALL: Resources(gold=50, wood=20)
        }
        
        # Tech tree
        self.researched_techs = set()
        self.tech_tree = {
            'improved_mining': {'cost': 200, 'effect': 'gold_bonus'},
            'advanced_farming': {'cost': 200, 'effect': 'food_bonus'},
            'military_training': {'cost': 300, 'effect': 'unit_attack'},
            'fortification': {'cost': 300, 'effect': 'building_hp'}
        }
        
        # Initialize game
        self.initialize_game()
    
    def initialize_game(self):
        """Set up initial game state"""
        # Player starting position
        start_x, start_y = 5, 5
        
        # Create player base
        base = Building(BuildingType.BASE, start_x, start_y, 'player')
        self.buildings.append(base)
        self.map.reveal(start_x, start_y, base.sight)
        
        # Create player starting units
        for i in range(3):
            worker = Unit(UnitType.WORKER, start_x + 3 + i, start_y + 3, 'player')
            self.units.append(worker)
            self.map.reveal(worker.x, worker.y, worker.sight)
        
        # Create enemy base
        enemy_x, enemy_y = 40, 30
        enemy_base = Building(BuildingType.BASE, enemy_x, enemy_y, 'enemy')
        self.buildings.append(enemy_base)
        
        # Create enemy starting units
        for i in range(3):
            worker = Unit(UnitType.WORKER, enemy_x + 3 + i, enemy_y + 3, 'enemy')
            self.units.append(worker)
    
    def handle_click(self, x: int, y: int, button: int):
        """Handle mouse click"""
        # Convert screen to world coordinates
        world_x = (x + self.camera_x) // 20
        world_y = (y + self.camera_y) // 20
        
        if button == 1:  # Left click - selection
            self.select_at(world_x, world_y)
        elif button == 3:  # Right click - action
            self.issue_command(world_x, world_y)
    
    def select_at(self, x: int, y: int):
        """Select units/buildings at position"""
        # Clear previous selection
        for unit in self.units:
            unit.selected = False
        for building in self.buildings:
            building.selected = False
        self.selected = []
        
        # Select unit at position
        for unit in self.units:
            if unit.x == x and unit.y == y and unit.faction == 'player':
                unit.selected = True
                self.selected.append(unit)
                return
        
        # Select building at position
        for building in self.buildings:
            if (building.x <= x < building.x + building.size and
                building.y <= y < building.y + building.size and
                building.faction == 'player'):
                building.selected = True
                self.selected.append(building)
                return
    
    def issue_command(self, x: int, y: int):
        """Issue command to selected units"""
        for entity in self.selected:
            if isinstance(entity, Unit):
                # Check for enemy at target
                enemy = None
                for unit in self.units:
                    if unit.faction != entity.faction and unit.x == x and unit.y == y:
                        enemy = unit
                        break
                
                if not enemy:
                    for building in self.buildings:
                        if (building.faction != entity.faction and
                            building.x <= x < building.x + building.size and
                            building.y <= y < building.y + building.size):
                            enemy = building
                            break
                
                if enemy:
                    # Attack command
                    entity.target = enemy
                else:
                    # Move command
                    entity.target_x = x
                    entity.target_y = y
                    entity.path = Pathfinding.find_path(
                        (entity.x, entity.y),
                        (x, y),
                        self.map
                    )
                    entity.moving = bool(entity.path)
    
    def train_unit(self, unit_type: UnitType, building: Building):
        """Train a unit from building"""
        if unit_type not in building.produces:
            return False
        
        cost = self.unit_costs[unit_type]
        if not self.resources.can_afford(cost):
            return False
        
        self.resources.subtract(cost)
        building.production_queue.append({
            'type': unit_type,
            'time': 180  # 3 seconds at 60 FPS
        })
        
        return True
    
    def build_structure(self, building_type: BuildingType, x: int, y: int):
        """Build a structure"""
        cost = self.building_costs[building_type]
        if not self.resources.can_afford(cost):
            return False
        
        # Check if area is clear
        size = Building(building_type, 0, 0, 'player').size
        for dy in range(size):
            for dx in range(size):
                if not self.map.is_passable(x + dx, y + dy):
                    return False
        
        self.resources.subtract(cost)
        
        # Create building
        building = Building(building_type, x, y, 'player')
        building.construction_progress = 0
        building.is_complete = False
        self.buildings.append(building)
        
        # Mark tiles as occupied
        for dy in range(size):
            for dx in range(size):
                self.map.tiles[y + dy][x + dx]['occupied'] = True
        
        return True
    
    def research_tech(self, tech_name: str):
        """Research a technology"""
        if tech_name in self.researched_techs:
            return False
        
        tech = self.tech_tree.get(tech_name)
        if not tech:
            return False
        
        if self.resources.gold < tech['cost']:
            return False
        
        self.resources.gold -= tech['cost']
        self.researched_techs.add(tech_name)
        
        # Apply tech effects
        if tech['effect'] == 'gold_bonus':
            for building in self.buildings:
                if building.type == BuildingType.MINE:
                    building.generates['gold'] = int(building.generates['gold'] * 1.25)
        elif tech['effect'] == 'food_bonus':
            for building in self.buildings:
                if building.type == BuildingType.FARM:
                    building.generates['food'] = int(building.generates['food'] * 1.25)
        elif tech['effect'] == 'unit_attack':
            for unit in self.units:
                unit.attack = int(unit.attack * 1.2)
        elif tech['effect'] == 'building_hp':
            for building in self.buildings:
                building.max_hp = int(building.max_hp * 1.25)
                building.hp = building.max_hp
        
        return True
    
    def update(self, dt: float):
        """Update game state"""
        # Update units
        for unit in self.units[:]:
            # Movement
            if unit.path:
                next_pos = unit.path[0]
                unit.x, unit.y = next_pos
                unit.path.pop(0)
                
                if unit.faction == 'player':
                    self.map.reveal(unit.x, unit.y, unit.sight)
                
                if not unit.path:
                    unit.moving = False
            
            # Combat
            if unit.target:
                dx = abs(unit.x - unit.target.x)
                dy = abs(unit.y - unit.target.y)
                dist = max(dx, dy)
                
                if dist <= unit.range:
                    if unit.cooldown <= 0:
                        # Attack
                        damage = max(1, unit.attack - unit.target.defense)
                        unit.target.hp -= damage
                        unit.cooldown = 60  # 1 second
                        
                        if unit.target.hp <= 0:
                            unit.target = None
                else:
                    # Move toward target
                    unit.target_x = unit.target.x
                    unit.target_y = unit.target.y
                    unit.path = Pathfinding.find_path(
                        (unit.x, unit.y),
                        (unit.target_x, unit.target_y),
                        self.map
                    )
            
            # Cooldown
            if unit.cooldown > 0:
                unit.cooldown -= 1
            
            # Death
            if unit.hp <= 0:
                self.units.remove(unit)
        
        # Update buildings
        for building in self.buildings[:]:
            # Construction
            if not building.is_complete:
                building.construction_progress += 1
                if building.construction_progress >= 100:
                    building.is_complete = True
                    if building.faction == 'player':
                        self.map.reveal(building.x, building.y, building.sight)
            
            # Production
            if building.production_queue and building.is_complete:
                production = building.production_queue[0]
                building.production_progress += 1
                
                if building.production_progress >= production['time']:
                    # Spawn unit
                    unit = Unit(
                        production['type'],
                        building.x + building.size,
                        building.y + building.size,
                        building.faction
                    )
                    self.units.append(unit)
                    
                    building.production_queue.pop(0)
                    building.production_progress = 0
            
            # Resource generation
            if building.generates and building.is_complete:
                for resource, amount in building.generates.items():
                    if resource == 'gold':
                        self.resources.gold += amount / 60  # Per second
                    elif resource == 'food':
                        self.resources.food += amount / 60
                    elif resource == 'wood':
                        self.resources.wood += amount / 60
            
            # Tower attacks
            if building.type == BuildingType.TOWER and building.is_complete:
                if building.cooldown <= 0:
                    # Find nearest enemy
                    nearest_enemy = None
                    nearest_dist = float('inf')
                    
                    for unit in self.units:
                        if unit.faction != building.faction:
                            dist = max(abs(unit.x - building.x), 
                                     abs(unit.y - building.y))
                            if dist <= building.range and dist < nearest_dist:
                                nearest_enemy = unit
                                nearest_dist = dist
                    
                    if nearest_enemy:
                        damage = building.attack
                        nearest_enemy.hp -= damage
                        building.cooldown = 60
                
                if building.cooldown > 0:
                    building.cooldown -= 1
            
            # Death
            if building.hp <= 0:
                # Clear occupied tiles
                for dy in range(building.size):
                    for dx in range(building.size):
                        self.map.tiles[building.y + dy][building.x + dx]['occupied'] = False
                
                self.buildings.remove(building)
        
        # Update AI
        self.ai_controller.update(self, dt)
    
    def render(self):
        """Render game"""
        self.screen.fill((34, 139, 34))
        
        # Calculate visible tiles
        tile_size = 20
        start_x = self.camera_x // tile_size
        start_y = self.camera_y // tile_size
        end_x = min(self.map.width, start_x + self.screen.get_width() // tile_size + 2)
        end_y = min(self.map.height, start_y + self.screen.get_height() // tile_size + 2)
        
        # Draw terrain
        terrain_colors = {
            'grass': (34, 139, 34),
            'forest': (0, 100, 0),
            'mountain': (139, 137, 137),
            'water': (64, 164, 223)
        }
        
        for y in range(start_y, end_y):
            for x in range(start_x, end_x):
                if not self.map.fog[y][x]:
                    # Fog of war
                    color = (20, 20, 20)
                else:
                    tile = self.map.tiles[y][x]
                    color = terrain_colors[tile['terrain']]
                
                screen_x = x * tile_size - self.camera_x
                screen_y = y * tile_size - self.camera_y
                
                pygame.draw.rect(self.screen, color,
                               (screen_x, screen_y, tile_size, tile_size))
                
                # Draw resources
                if self.map.fog[y][x] and tile['resource']:
                    resource_colors = {
                        'gold': (255, 215, 0),
                        'food': (139, 69, 19),
                        'wood': (101, 67, 33)
                    }
                    pygame.draw.circle(self.screen,
                                     resource_colors[tile['resource']],
                                     (screen_x + tile_size//2, screen_y + tile_size//2),
                                     5)
        
        # Draw buildings
        for building in self.buildings:
            screen_x = building.x * tile_size - self.camera_x
            screen_y = building.y * tile_size - self.camera_y
            size = building.size * tile_size
            
            color = (100, 100, 200) if building.faction == 'player' else (200, 100, 100)
            
            if building.is_complete:
                pygame.draw.rect(self.screen, color,
                               (screen_x, screen_y, size, size))
            else:
                # Under construction
                pygame.draw.rect(self.screen, color,
                               (screen_x, screen_y, size, size), 2)
                # Progress bar
                progress_width = size * (building.construction_progress / 100)
                pygame.draw.rect(self.screen, (0, 255, 0),
                               (screen_x, screen_y - 5, progress_width, 3))
            
            # Selection indicator
            if building.selected:
                pygame.draw.rect(self.screen, (255, 255, 0),
                               (screen_x - 2, screen_y - 2, size + 4, size + 4), 2)
            
            # Health bar
            if building.hp < building.max_hp:
                health_width = size * (building.hp / building.max_hp)
                pygame.draw.rect(self.screen, (255, 0, 0),
                               (screen_x, screen_y - 10, size, 3))
                pygame.draw.rect(self.screen, (0, 255, 0),
                               (screen_x, screen_y - 10, health_width, 3))
        
        # Draw units
        for unit in self.units:
            screen_x = unit.x * tile_size - self.camera_x + tile_size//2
            screen_y = unit.y * tile_size - self.camera_y + tile_size//2
            
            color = (50, 50, 200) if unit.faction == 'player' else (200, 50, 50)
            
            pygame.draw.circle(self.screen, color, (screen_x, screen_y), 8)
            
            # Selection indicator
            if unit.selected:
                pygame.draw.circle(self.screen, (255, 255, 0),
                                 (screen_x, screen_y), 12, 2)
            
            # Health bar
            if unit.hp < unit.max_hp:
                bar_width = 20
                health_width = bar_width * (unit.hp / unit.max_hp)
                pygame.draw.rect(self.screen, (255, 0, 0),
                               (screen_x - bar_width//2, screen_y - 15, bar_width, 3))
                pygame.draw.rect(self.screen, (0, 255, 0),
                               (screen_x - bar_width//2, screen_y - 15, health_width, 3))
        
        # Draw UI
        self.render_ui()
        
        pygame.display.flip()
    
    def render_ui(self):
        """Render user interface"""
        # Resource bar
        ui_height = 40
        pygame.draw.rect(self.screen, (50, 50, 50),
                       (0, 0, self.screen.get_width(), ui_height))
        
        font = pygame.font.Font(None, 24)
        
        # Resources
        resources_text = f"Gold: {int(self.resources.gold)}  " \
                        f"Food: {int(self.resources.food)}  " \
                        f"Wood: {int(self.resources.wood)}"
        
        text_surface = font.render(resources_text, True, (255, 255, 255))
        self.screen.blit(text_surface, (10, 10))
        
        # Selection info
        if self.selected:
            entity = self.selected[0]
            if isinstance(entity, Unit):
                info = f"Unit: {entity.type.value}  HP: {entity.hp}/{entity.max_hp}"
            else:
                info = f"Building: {entity.type.value}  HP: {entity.hp}/{entity.max_hp}"
            
            info_surface = font.render(info, True, (255, 255, 255))
            self.screen.blit(info_surface, (10, self.screen.get_height() - 30))
    
    def run(self):
        """Main game loop"""
        running = True
        
        while running:
            dt = self.clock.tick(60) / 1000.0
            
            # Handle events
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    running = False
                
                elif event.type == pygame.MOUSEBUTTONDOWN:
                    self.handle_click(event.pos[0], event.pos[1], event.button)
                
                elif event.type == pygame.KEYDOWN:
                    # Camera movement
                    speed = 10
                    if event.key == pygame.K_LEFT:
                        self.camera_x = max(0, self.camera_x - speed)
                    elif event.key == pygame.K_RIGHT:
                        self.camera_x = min(self.map.width * 20 - self.screen.get_width(),
                                          self.camera_x + speed)
                    elif event.key == pygame.K_UP:
                        self.camera_y = max(0, self.camera_y - speed)
                    elif event.key == pygame.K_DOWN:
                        self.camera_y = min(self.map.height * 20 - self.screen.get_height(),
                                          self.camera_y + speed)
            
            # Update
            self.update(dt)
            
            # Render
            self.render()
        
        pygame.quit()

if __name__ == "__main__":
    game = StrategyGame()
    game.run()</code></pre>

    <h2>Key Features Implemented</h2>
    
    <div style="background-color: #e8f5e9; padding: 20px; border-radius: 10px; margin: 20px 0;">
        <h3>✅ Complete Systems</h3>
        <ul>
            <li><strong>Resource Management:</strong> Gold, food, and wood economy with income generation</li>
            <li><strong>Unit System:</strong> Workers, soldiers, archers, cavalry, and siege units with unique stats</li>
            <li><strong>Building System:</strong> Base, barracks, mines, farms, towers, and walls</li>
            <li><strong>Pathfinding:</strong> A* algorithm for intelligent unit movement</li>
            <li><strong>Fog of War:</strong> Vision-based map exploration</li>
            <li><strong>Combat:</strong> Range-based attacks with cooldowns and damage calculations</li>
            <li><strong>AI Opponent:</strong> Strategic decision-making with multiple difficulty levels</li>
            <li><strong>Tech Tree:</strong> Research system with economic and military upgrades</li>
            <li><strong>Production Queues:</strong> Unit training with time-based completion</li>
            <li><strong>Construction:</strong> Building placement and construction progress</li>
        </ul>
    </div>

    <h2>Usage Instructions</h2>
    
    <div style="background-color: #fff3e0; padding: 20px; border-radius: 10px; margin: 20px 0;">
        <h3>🎮 How to Play</h3>
        <ol>
            <li><strong>Install Pygame:</strong> <code>pip install pygame</code></li>
            <li><strong>Run the game:</strong> <code>python strategy_game.py</code></li>
            <li><strong>Controls:</strong>
                <ul>
                    <li>Left-click to select units/buildings</li>
                    <li>Right-click to move units or attack</li>
                    <li>Arrow keys to move camera</li>
                    <li>Build structures by selecting a builder unit</li>
                    <li>Train units from barracks</li>
                </ul>
            </li>
        </ol>
    </div>

    <h2>Customization Options</h2>
    
    <div style="background-color: #f3e5f5; padding: 20px; border-radius: 10px; margin: 20px 0;">
        <h3>🔧 Easy Modifications</h3>
        <ul>
            <li><strong>Map Size:</strong> Change the Map constructor parameters</li>
            <li><strong>Starting Resources:</strong> Modify Resources initialization in StrategyGame</li>
            <li><strong>Unit Stats:</strong> Edit the stats dictionary in Unit class</li>
            <li><strong>Building Costs:</strong> Adjust unit_costs and building_costs dictionaries</li>
            <li><strong>AI Difficulty:</strong> Change AIController difficulty parameter</li>
            <li><strong>Tech Effects:</strong> Modify research_tech method effects</li>
        </ul>
    </div>

    <!-- Lesson Navigation -->
    <nav class="lesson-nav" aria-label="Lesson navigation">
        <a href="genres_strategy.html" class="prev-lesson">Back to Strategy Game Lesson</a>
        <a href="genres_puzzle.html" class="next-lesson">Next: Puzzle Game Logic</a>
    </nav>
    
    </main>
</body>
</html>