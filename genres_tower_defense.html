<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Master tower defense game patterns. Learn tower placement, enemy pathing, wave systems, upgrade mechanics, and resource management.">
    <title>Tower Defense Patterns - Different Game Genres</title>
    <link rel="stylesheet" href="styles/main.css">
    <link rel="stylesheet" href="styles/enhanced.css">
    <link rel="icon" href="favicon.png">
    <script type="module">
      import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
      mermaid.initialize({ startOnLoad: true });
    </script>
    <script src="/js/clipboard.js" defer></script>
</head>
<body>
    <!-- Skip to main content for accessibility -->
    <a href="#main-content" class="skip-to-main">Skip to main content</a>
    
    <!-- Progress indicator -->
    <div class="progress-indicator" role="progressbar" aria-label="Page scroll progress">
        <div class="progress-bar"></div>
    </div>
    
    <main id="main-content">
    <header role="banner">
        <h1>Tower Defense Patterns</h1>
        <div class="reading-time" aria-label="Estimated reading time"></div>
    </header>
    
    <!-- Breadcrumb Navigation -->
    <nav class="breadcrumb" aria-label="Breadcrumb">
        <a href="index.html">Course Home</a>
        <span class="separator">›</span>
        <span class="current">Advanced Module - Section 3: Different Game Genres - Lesson 5</span>
    </nav>

    <h2>Building Strategic Tower Defense Games</h2>
    
    <div style="background-color: #f0f8ff; padding: 20px; border-radius: 10px; margin: 20px 0;">
        <p>Master tower defense mechanics! Create strategic tower placement, enemy wave systems, upgrade paths, resource management, and special abilities! 🏰🎯💥</p>
    </div>

    <h2>Understanding Tower Defense Systems</h2>
    
    <div style="background-color: #fff5f5; padding: 20px; border-radius: 10px; margin: 20px 0;">
        <h3>🎯 Core Tower Defense Mechanics</h3>
        <p>Great tower defense games balance strategy with action:</p>
        <ul>
            <li><strong>Tower Types:</strong> Different towers for different strategies</li>
            <li><strong>Enemy Pathing:</strong> Predictable paths with strategic importance</li>
            <li><strong>Wave Systems:</strong> Progressive difficulty and variety</li>
            <li><strong>Economy:</strong> Resource generation and management</li>
            <li><strong>Upgrades:</strong> Tower improvements and specialization</li>
            <li><strong>Special Abilities:</strong> Active player intervention</li>
        </ul>
    </div>

    <div class="mermaid">
    graph TD
        A["Tower Defense Core"] --> B["Tower System"]
        A --> C["Enemy System"]
        A --> D["Wave Manager"]
        A --> E["Economy"]
        
        B --> F["Tower Types"]
        B --> G["Targeting AI"]
        B --> H["Upgrade Paths"]
        
        C --> I["Enemy Types"]
        C --> J["Pathfinding"]
        C --> K["Health/Armor"]
        
        D --> L["Wave Composition"]
        D --> M["Spawn Timing"]
        D --> N["Difficulty Scaling"]
        
        E --> O["Resource Generation"]
        E --> P["Tower Costs"]
        E --> Q["Upgrade Pricing"]
    </div>

    <h2>Tower Defense Mathematics</h2>
    
    <div style="background-color: #f9f9f9; padding: 20px; border-radius: 10px; margin: 20px 0;">
        <h3>📐 Core Calculations</h3>
        <pre><code class="language-python">
# Damage Per Second (DPS)
dps = damage * fire_rate

# Effective DPS with armor
effective_damage = max(1, damage - armor)
effective_dps = effective_damage * fire_rate

# Tower efficiency
efficiency = total_damage_dealt / tower_cost

# Range check (circular)
distance = sqrt((enemy.x - tower.x)² + (enemy.y - tower.y)²)
in_range = distance <= tower.range

# Projectile leading (predictive targeting)
time_to_impact = distance / projectile_speed
future_x = enemy.x + enemy.vx * time_to_impact
future_y = enemy.y + enemy.vy * time_to_impact

# Wave difficulty scaling
enemy_health = base_health * (1 + wave_number * 0.1)
enemy_count = base_count + floor(wave_number / 5)
        </code></pre>
    </div>

    <h2>Interactive Tower Defense Demo</h2>
    
    <div class="canvas-wrapper" style="text-align: center;">
        <canvas id="towerDefenseCanvas" width="900" height="600" style="border: 2px solid #333; display: inline-block; background: #2d4a2b;"></canvas>
    </div>
    
    <div style="text-align: center; margin-top: 10px;">
        <p>Build towers to defend against waves of enemies! Click to place towers, upgrade them, and use special abilities!</p>
        
        <!-- Tower Selection -->
        <div style="margin: 10px auto; padding: 10px; background-color: rgba(0,0,0,0.5); border-radius: 5px;">
            <h4 style="color: white;">Select Tower:</h4>
            <div id="towerButtons" style="display: inline-block;">
                <button class="tower-btn active" onclick="selectTower('basic')" data-tower="basic">
                    🏹 Basic<br><small>$100</small>
                </button>
                <button class="tower-btn" onclick="selectTower('cannon')" data-tower="cannon">
                    💣 Cannon<br><small>$200</small>
                </button>
                <button class="tower-btn" onclick="selectTower('laser')" data-tower="laser">
                    ⚡ Laser<br><small>$300</small>
                </button>
                <button class="tower-btn" onclick="selectTower('slow')" data-tower="slow">
                    ❄️ Slow<br><small>$150</small>
                </button>
                <button class="tower-btn" onclick="selectTower('money')" data-tower="money">
                    💰 Bank<br><small>$250</small>
                </button>
            </div>
        </div>
        
        <!-- Game Controls -->
        <div style="margin: 10px auto;">
            <button onclick="startWave()" id="waveBtn">🚀 Start Wave</button>
            <button onclick="pauseGame()">⏸️ Pause</button>
            <button onclick="speedUp()">⏩ Speed x2</button>
            <button onclick="sellMode()">💸 Sell Mode</button>
            <button onclick="resetGame()">🔄 Reset</button>
        </div>
        
        <!-- Game Stats -->
        <div style="margin-top: 10px; background-color: rgba(0,0,0,0.6); padding: 10px; border-radius: 5px;">
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 10px;">
                <div style="color: gold;">
                    💰 Gold: <span id="gold">500</span>
                </div>
                <div style="color: white;">
                    🏰 Lives: <span id="lives">20</span>
                </div>
                <div style="color: white;">
                    🌊 Wave: <span id="wave">0</span>
                </div>
                <div style="color: white;">
                    👾 Enemies: <span id="enemies">0</span>
                </div>
                <div style="color: white;">
                    🏆 Score: <span id="tdScore">0</span>
                </div>
                <div style="color: white;">
                    ⚡ Power: <span id="power">3</span>
                </div>
            </div>
        </div>
        
        <!-- Tower Info Panel -->
        <div id="towerInfo" style="margin-top: 10px; padding: 10px; background-color: rgba(0,0,0,0.7); border-radius: 5px; display: none;">
            <h4 style="color: gold; margin: 5px;">Tower Information</h4>
            <div id="towerDetails" style="color: white;"></div>
            <button onclick="upgradeTower()" id="upgradeBtn">⬆️ Upgrade</button>
            <button onclick="sellTower()" id="sellBtn">💸 Sell</button>
        </div>
        
        <!-- Wave Preview -->
        <div style="margin-top: 10px; padding: 10px; background-color: rgba(0,0,0,0.5); border-radius: 5px;">
            <div style="color: white;">Next Wave: <span id="wavePreview">10 Basic enemies</span></div>
            <div id="waveProgress" style="width: 100%; height: 10px; background: rgba(0,0,0,0.5); border-radius: 5px; margin-top: 5px;">
                <div id="waveBar" style="width: 0%; height: 100%; background: linear-gradient(90deg, #ff6b6b, #ffd93d); border-radius: 5px;"></div>
            </div>
        </div>
    </div>

    <style>
        button {
            margin: 2px;
            padding: 8px 12px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            transition: all 0.3s;
        }
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }
        button:active {
            transform: translateY(0);
        }
        .tower-btn {
            width: 80px;
            height: 60px;
            margin: 5px;
            padding: 5px;
            background: linear-gradient(135deg, #4a5568 0%, #2d3748 100%);
            border: 2px solid #2d3748;
        }
        .tower-btn.active {
            background: linear-gradient(135deg, #48bb78 0%, #38a169 100%);
            border-color: #38a169;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }
        .tower-btn:hover {
            border-color: #ffd93d;
        }
        .tower-btn small {
            display: block;
            font-size: 11px;
            color: #ffd93d;
        }
    </style>

    <script>
        console.log('Tower Defense Demo starting...');

        const canvas = document.getElementById('towerDefenseCanvas');
        const ctx = canvas.getContext('2d');

        // Game state
        let gameState = {
            gold: 500,
            lives: 20,
            wave: 0,
            score: 0,
            power: 3,
            paused: false,
            speed: 1,
            selectedTower: 'basic',
            selectedTowerObj: null,
            sellModeActive: false,
            gameOver: false
        };

        // Grid system
        const GRID_SIZE = 30;
        const GRID_COLS = Math.floor(canvas.width / GRID_SIZE);
        const GRID_ROWS = Math.floor(canvas.height / GRID_SIZE);

        // Path waypoints for enemies
        const PATH = [
            { x: 0, y: 300 },
            { x: 200, y: 300 },
            { x: 200, y: 150 },
            { x: 500, y: 150 },
            { x: 500, y: 450 },
            { x: 700, y: 450 },
            { x: 700, y: 300 },
            { x: 900, y: 300 }
        ];

        // Tower types
        const TOWER_TYPES = {
            basic: {
                name: 'Basic Tower',
                cost: 100,
                damage: 10,
                range: 100,
                fireRate: 1,
                color: '#8B7355',
                projectileColor: '#FFD700',
                projectileSpeed: 300,
                icon: '🏹'
            },
            cannon: {
                name: 'Cannon Tower',
                cost: 200,
                damage: 30,
                range: 80,
                fireRate: 0.5,
                color: '#696969',
                projectileColor: '#FF4500',
                projectileSpeed: 200,
                splash: 40,
                icon: '💣'
            },
            laser: {
                name: 'Laser Tower',
                cost: 300,
                damage: 5,
                range: 120,
                fireRate: 10,
                color: '#4169E1',
                projectileColor: '#00FFFF',
                instant: true,
                icon: '⚡'
            },
            slow: {
                name: 'Slow Tower',
                cost: 150,
                damage: 5,
                range: 90,
                fireRate: 2,
                color: '#87CEEB',
                projectileColor: '#E0FFFF',
                projectileSpeed: 250,
                slowEffect: 0.5,
                slowDuration: 2,
                icon: '❄️'
            },
            money: {
                name: 'Money Tower',
                cost: 250,
                damage: 0,
                range: 0,
                fireRate: 0.1,
                color: '#FFD700',
                goldGeneration: 5,
                icon: '💰'
            }
        };

        // Enemy types
        const ENEMY_TYPES = {
            basic: {
                name: 'Basic',
                health: 100,
                speed: 50,
                armor: 0,
                value: 10,
                color: '#FF6B6B',
                size: 10
            },
            fast: {
                name: 'Fast',
                health: 75,
                speed: 100,
                armor: 0,
                value: 15,
                color: '#FFD93D',
                size: 8
            },
            tank: {
                name: 'Tank',
                health: 300,
                speed: 30,
                armor: 5,
                value: 30,
                color: '#6BCB77',
                size: 15
            },
            flying: {
                name: 'Flying',
                health: 150,
                speed: 60,
                armor: 2,
                value: 20,
                color: '#4D96FF',
                size: 12,
                flying: true
            },
            boss: {
                name: 'Boss',
                health: 1000,
                speed: 25,
                armor: 10,
                value: 100,
                color: '#9D4EDD',
                size: 20
            }
        };

        // Wave definitions
        const WAVES = [
            { enemies: [{ type: 'basic', count: 10, spacing: 1000 }] },
            { enemies: [{ type: 'basic', count: 15, spacing: 800 }] },
            { enemies: [{ type: 'basic', count: 10, spacing: 800 }, { type: 'fast', count: 5, spacing: 600 }] },
            { enemies: [{ type: 'fast', count: 10, spacing: 500 }] },
            { enemies: [{ type: 'basic', count: 20, spacing: 600 }, { type: 'tank', count: 3, spacing: 1500 }] },
            { enemies: [{ type: 'tank', count: 5, spacing: 1200 }, { type: 'fast', count: 10, spacing: 400 }] },
            { enemies: [{ type: 'flying', count: 8, spacing: 800 }] },
            { enemies: [{ type: 'basic', count: 30, spacing: 400 }, { type: 'flying', count: 5, spacing: 1000 }] },
            { enemies: [{ type: 'tank', count: 10, spacing: 1000 }, { type: 'flying', count: 10, spacing: 700 }] },
            { enemies: [{ type: 'boss', count: 1, spacing: 0 }, { type: 'basic', count: 20, spacing: 500 }] }
        ];

        // Game objects
        let towers = [];
        let enemies = [];
        let projectiles = [];
        let particles = [];
        let waveSpawner = null;

        // Tower class
        class Tower {
            constructor(x, y, type) {
                this.x = x;
                this.y = y;
                this.type = type;
                this.stats = { ...TOWER_TYPES[type] };
                this.level = 1;
                this.lastFire = 0;
                this.target = null;
                this.angle = 0;
                this.kills = 0;
                this.damageDealt = 0;
                
                // Money tower specific
                if (type === 'money') {
                    this.lastGeneration = Date.now();
                }
            }
            
            update(dt) {
                // Money generation
                if (this.type === 'money') {
                    const now = Date.now();
                    if (now - this.lastGeneration > 1000 / this.stats.fireRate) {
                        gameState.gold += this.stats.goldGeneration * this.level;
                        this.lastGeneration = now;
                        
                        // Money particle effect
                        particles.push(new Particle(
                            this.x, this.y - 20,
                            '+$' + (this.stats.goldGeneration * this.level),
                            '#FFD700', 1000
                        ));
                    }
                    return;
                }
                
                // Find target
                this.findTarget();
                
                // Rotate towards target
                if (this.target) {
                    const dx = this.target.x - this.x;
                    const dy = this.target.y - this.y;
                    this.angle = Math.atan2(dy, dx);
                    
                    // Fire projectile
                    const now = Date.now();
                    if (now - this.lastFire > 1000 / this.stats.fireRate) {
                        this.fire();
                        this.lastFire = now;
                    }
                }
            }
            
            findTarget() {
                // Clear dead or out-of-range target
                if (this.target) {
                    if (this.target.isDead || !this.isInRange(this.target)) {
                        this.target = null;
                    }
                }
                
                // Find new target if needed
                if (!this.target) {
                    // Different targeting strategies
                    let potentialTargets = enemies.filter(e => 
                        !e.isDead && this.isInRange(e) && 
                        (!e.flying || this.type === 'laser')
                    );
                    
                    if (potentialTargets.length > 0) {
                        // Target closest to exit
                        this.target = potentialTargets.reduce((closest, enemy) => {
                            return enemy.pathProgress > closest.pathProgress ? enemy : closest;
                        });
                    }
                }
            }
            
            isInRange(enemy) {
                const dx = enemy.x - this.x;
                const dy = enemy.y - this.y;
                return Math.sqrt(dx * dx + dy * dy) <= this.stats.range;
            }
            
            fire() {
                if (!this.target) return;
                
                if (this.stats.instant) {
                    // Instant hit (laser)
                    this.dealDamage(this.target, this.stats.damage * this.level);
                    
                    // Laser beam effect
                    particles.push(new LaserBeam(
                        this.x, this.y,
                        this.target.x, this.target.y,
                        this.stats.projectileColor
                    ));
                } else {
                    // Create projectile
                    projectiles.push(new Projectile(
                        this.x, this.y,
                        this.target,
                        this.stats.damage * this.level,
                        this.stats.projectileSpeed,
                        this.stats.projectileColor,
                        this
                    ));
                }
            }
            
            dealDamage(enemy, damage) {
                enemy.takeDamage(damage);
                this.damageDealt += damage;
                
                if (enemy.isDead) {
                    this.kills++;
                }
                
                // Apply special effects
                if (this.stats.slowEffect && !enemy.slowed) {
                    enemy.applySlowEffect(this.stats.slowEffect, this.stats.slowDuration);
                }
            }
            
            upgrade() {
                const upgradeCost = this.stats.cost * this.level;
                if (gameState.gold >= upgradeCost) {
                    gameState.gold -= upgradeCost;
                    this.level++;
                    
                    // Visual upgrade effect
                    for (let i = 0; i < 10; i++) {
                        const angle = (Math.PI * 2 / 10) * i;
                        particles.push(new Particle(
                            this.x + Math.cos(angle) * 20,
                            this.y + Math.sin(angle) * 20,
                            '⬆️', '#FFD700', 500
                        ));
                    }
                    
                    return true;
                }
                return false;
            }
            
            getSellPrice() {
                let totalValue = this.stats.cost;
                for (let i = 2; i <= this.level; i++) {
                    totalValue += this.stats.cost * (i - 1);
                }
                return Math.floor(totalValue * 0.7);
            }
            
            draw() {
                // Draw range when selected
                if (this === gameState.selectedTowerObj) {
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.stats.range, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
                
                // Draw tower base
                ctx.fillStyle = this.stats.color;
                ctx.fillRect(this.x - 15, this.y - 15, 30, 30);
                
                // Draw tower level indicators
                ctx.fillStyle = '#FFD700';
                for (let i = 0; i < this.level; i++) {
                    ctx.fillRect(this.x - 15 + i * 5, this.y - 20, 3, 3);
                }
                
                // Draw tower turret/icon
                ctx.save();
                ctx.translate(this.x, this.y);
                
                if (this.type !== 'money') {
                    ctx.rotate(this.angle);
                    
                    // Draw barrel
                    ctx.fillStyle = '#333';
                    ctx.fillRect(0, -3, 20, 6);
                }
                
                // Draw icon
                ctx.font = '20px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(this.stats.icon, 0, 0);
                
                ctx.restore();
            }
        }

        // Enemy class
        class Enemy {
            constructor(type, pathIndex = 0) {
                this.type = type;
                this.stats = { ...ENEMY_TYPES[type] };
                this.maxHealth = this.stats.health * (1 + gameState.wave * 0.1);
                this.health = this.maxHealth;
                this.speed = this.stats.speed;
                this.pathIndex = pathIndex;
                this.pathProgress = 0;
                this.x = PATH[0].x;
                this.y = PATH[0].y;
                this.isDead = false;
                this.slowed = false;
                this.slowEndTime = 0;
                
                // Position interpolation
                this.targetX = PATH[0].x;
                this.targetY = PATH[0].y;
            }
            
            update(dt) {
                if (this.isDead) return;
                
                // Check slow effect
                if (this.slowed && Date.now() > this.slowEndTime) {
                    this.slowed = false;
                    this.speed = this.stats.speed;
                }
                
                // Move towards next waypoint
                if (this.pathIndex < PATH.length - 1) {
                    const target = PATH[this.pathIndex + 1];
                    const dx = target.x - this.x;
                    const dy = target.y - this.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < 5) {
                        // Reached waypoint
                        this.pathIndex++;
                        if (this.pathIndex >= PATH.length - 1) {
                            // Reached end
                            this.reachEnd();
                        }
                    } else {
                        // Move towards waypoint
                        const moveDistance = this.speed * dt * (this.slowed ? 0.5 : 1);
                        this.x += (dx / distance) * moveDistance;
                        this.y += (dy / distance) * moveDistance;
                        
                        // Update progress for targeting
                        this.pathProgress = this.pathIndex + (1 - distance / 100);
                    }
                }
            }
            
            takeDamage(damage) {
                const actualDamage = Math.max(1, damage - this.stats.armor);
                this.health -= actualDamage;
                
                // Damage number
                particles.push(new Particle(
                    this.x, this.y - 10,
                    '-' + Math.floor(actualDamage),
                    '#FF0000', 500
                ));
                
                if (this.health <= 0 && !this.isDead) {
                    this.die();
                }
            }
            
            applySlowEffect(slowFactor, duration) {
                this.slowed = true;
                this.speed = this.stats.speed * slowFactor;
                this.slowEndTime = Date.now() + duration * 1000;
            }
            
            die() {
                this.isDead = true;
                gameState.gold += this.stats.value;
                gameState.score += this.stats.value * 10;
                
                // Death effect
                for (let i = 0; i < 8; i++) {
                    const angle = (Math.PI * 2 / 8) * i;
                    particles.push(new Particle(
                        this.x + Math.cos(angle) * 10,
                        this.y + Math.sin(angle) * 10,
                        '💀', this.stats.color, 300
                    ));
                }
                
                // Gold popup
                particles.push(new Particle(
                    this.x, this.y,
                    '+$' + this.stats.value,
                    '#FFD700', 1000
                ));
            }
            
            reachEnd() {
                this.isDead = true;
                gameState.lives--;
                
                // Life lost effect
                particles.push(new Particle(
                    this.x, this.y,
                    '💔', '#FF0000', 1000
                ));
                
                if (gameState.lives <= 0) {
                    gameOver();
                }
            }
            
            draw() {
                if (this.isDead) return;
                
                // Draw shadow
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.beginPath();
                ctx.arc(this.x + 2, this.y + 2, this.stats.size, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw enemy
                ctx.fillStyle = this.slowed ? '#87CEEB' : this.stats.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.stats.size, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw border
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // Draw health bar
                if (this.health < this.maxHealth) {
                    const barWidth = this.stats.size * 2;
                    const barHeight = 4;
                    const barY = this.y - this.stats.size - 8;
                    
                    // Background
                    ctx.fillStyle = '#333';
                    ctx.fillRect(this.x - barWidth/2, barY, barWidth, barHeight);
                    
                    // Health
                    const healthPercent = this.health / this.maxHealth;
                    ctx.fillStyle = healthPercent > 0.5 ? '#4CAF50' : 
                                   healthPercent > 0.25 ? '#FFA500' : '#FF0000';
                    ctx.fillRect(this.x - barWidth/2, barY, barWidth * healthPercent, barHeight);
                }
                
                // Draw flying indicator
                if (this.stats.flying) {
                    ctx.fillStyle = '#4D96FF';
                    ctx.font = '12px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('✈️', this.x, this.y);
                }
            }
        }

        // Projectile class
        class Projectile {
            constructor(x, y, target, damage, speed, color, tower) {
                this.x = x;
                this.y = y;
                this.target = target;
                this.damage = damage;
                this.speed = speed;
                this.color = color;
                this.tower = tower;
                this.isDead = false;
                
                // Calculate leading shot
                const distance = Math.sqrt(
                    Math.pow(target.x - x, 2) + 
                    Math.pow(target.y - y, 2)
                );
                const timeToImpact = distance / speed;
                
                // Predict where enemy will be
                const targetSpeed = target.speed * (target.slowed ? 0.5 : 1);
                if (target.pathIndex < PATH.length - 1) {
                    const nextWaypoint = PATH[target.pathIndex + 1];
                    const dx = nextWaypoint.x - target.x;
                    const dy = nextWaypoint.y - target.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    this.targetX = target.x + (dx / dist) * targetSpeed * timeToImpact;
                    this.targetY = target.y + (dy / dist) * targetSpeed * timeToImpact;
                } else {
                    this.targetX = target.x;
                    this.targetY = target.y;
                }
            }
            
            update(dt) {
                if (this.isDead) return;
                
                // Move towards target position
                const dx = this.targetX - this.x;
                const dy = this.targetY - this.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < 5 || (this.target && this.target.isDead)) {
                    // Hit target or target died
                    this.explode();
                } else {
                    // Move projectile
                    const moveDistance = this.speed * dt;
                    this.x += (dx / distance) * moveDistance;
                    this.y += (dy / distance) * moveDistance;
                    
                    // Check if hit any enemy
                    if (this.target && !this.target.isDead) {
                        const enemyDist = Math.sqrt(
                            Math.pow(this.target.x - this.x, 2) +
                            Math.pow(this.target.y - this.y, 2)
                        );
                        
                        if (enemyDist < this.target.stats.size) {
                            this.explode();
                        }
                    }
                }
            }
            
            explode() {
                this.isDead = true;
                
                if (this.tower.stats.splash) {
                    // Area damage
                    enemies.forEach(enemy => {
                        const distance = Math.sqrt(
                            Math.pow(enemy.x - this.x, 2) +
                            Math.pow(enemy.y - this.y, 2)
                        );
                        
                        if (distance <= this.tower.stats.splash) {
                            const splashDamage = this.damage * (1 - distance / this.tower.stats.splash);
                            this.tower.dealDamage(enemy, splashDamage);
                        }
                    });
                    
                    // Explosion effect
                    for (let i = 0; i < 12; i++) {
                        const angle = (Math.PI * 2 / 12) * i;
                        particles.push(new Particle(
                            this.x + Math.cos(angle) * 20,
                            this.y + Math.sin(angle) * 20,
                            '💥', '#FF4500', 300
                        ));
                    }
                } else if (this.target && !this.target.isDead) {
                    // Single target damage
                    this.tower.dealDamage(this.target, this.damage);
                }
            }
            
            draw() {
                if (this.isDead) return;
                
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, 4, 0, Math.PI * 2);
                ctx.fill();
                
                // Trail effect
                ctx.strokeStyle = this.color;
                ctx.globalAlpha = 0.5;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(this.x, this.y);
                ctx.lineTo(this.x - (this.targetX - this.x) * 0.1, 
                          this.y - (this.targetY - this.y) * 0.1);
                ctx.stroke();
                ctx.globalAlpha = 1;
            }
        }

        // Particle class
        class Particle {
            constructor(x, y, text, color, lifetime) {
                this.x = x;
                this.y = y;
                this.text = text;
                this.color = color;
                this.lifetime = lifetime;
                this.age = 0;
                this.vy = -50;
            }
            
            update(dt) {
                this.age += dt * 1000;
                this.y += this.vy * dt;
                this.vy += 100 * dt;
                
                return this.age < this.lifetime;
            }
            
            draw() {
                const alpha = 1 - (this.age / this.lifetime);
                ctx.globalAlpha = alpha;
                ctx.fillStyle = this.color;
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(this.text, this.x, this.y);
                ctx.globalAlpha = 1;
            }
        }

        // Laser beam effect
        class LaserBeam extends Particle {
            constructor(x1, y1, x2, y2, color) {
                super(x1, y1, '', color, 100);
                this.x2 = x2;
                this.y2 = y2;
            }
            
            draw() {
                const alpha = 1 - (this.age / this.lifetime);
                ctx.globalAlpha = alpha;
                ctx.strokeStyle = this.color;
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(this.x, this.y);
                ctx.lineTo(this.x2, this.y2);
                ctx.stroke();
                
                // Glow effect
                ctx.lineWidth = 8;
                ctx.globalAlpha = alpha * 0.3;
                ctx.stroke();
                ctx.globalAlpha = 1;
            }
        }

        // Wave spawner
        class WaveSpawner {
            constructor(waveNumber) {
                this.waveNumber = waveNumber;
                this.waveData = WAVES[Math.min(waveNumber, WAVES.length - 1)];
                this.enemyQueues = [];
                this.currentQueue = 0;
                this.lastSpawn = 0;
                this.waveComplete = false;
                
                // Build enemy queue
                this.waveData.enemies.forEach(group => {
                    for (let i = 0; i < group.count; i++) {
                        this.enemyQueues.push({
                            type: group.type,
                            delay: group.spacing
                        });
                    }
                });
                
                // Scale for infinite waves
                if (waveNumber >= WAVES.length) {
                    const scaleFactor = Math.floor(waveNumber / WAVES.length);
                    this.enemyQueues = this.enemyQueues.concat(this.enemyQueues);
                }
            }
            
            update() {
                if (this.waveComplete) return;
                
                const now = Date.now();
                if (this.currentQueue < this.enemyQueues.length) {
                    const enemyData = this.enemyQueues[this.currentQueue];
                    
                    if (now - this.lastSpawn > enemyData.delay) {
                        enemies.push(new Enemy(enemyData.type));
                        this.lastSpawn = now;
                        this.currentQueue++;
                    }
                } else {
                    this.waveComplete = true;
                }
            }
            
            getProgress() {
                return this.currentQueue / this.enemyQueues.length;
            }
        }

        // Game functions
        function placeTower(x, y, type) {
            const towerData = TOWER_TYPES[type];
            
            // Check if can afford
            if (gameState.gold < towerData.cost) {
                showMessage('Not enough gold!', '#FF0000');
                return false;
            }
            
            // Snap to grid
            const gridX = Math.floor(x / GRID_SIZE) * GRID_SIZE + GRID_SIZE / 2;
            const gridY = Math.floor(y / GRID_SIZE) * GRID_SIZE + GRID_SIZE / 2;
            
            // Check if position is valid (not on path or existing tower)
            if (!isValidTowerPosition(gridX, gridY)) {
                showMessage('Invalid position!', '#FF0000');
                return false;
            }
            
            // Place tower
            gameState.gold -= towerData.cost;
            const tower = new Tower(gridX, gridY, type);
            towers.push(tower);
            
            // Placement effect
            for (let i = 0; i < 8; i++) {
                const angle = (Math.PI * 2 / 8) * i;
                particles.push(new Particle(
                    gridX + Math.cos(angle) * 20,
                    gridY + Math.sin(angle) * 20,
                    '✨', '#FFD700', 500
                ));
            }
            
            return true;
        }

        function isValidTowerPosition(x, y) {
            // Check if on path
            for (let i = 0; i < PATH.length - 1; i++) {
                const p1 = PATH[i];
                const p2 = PATH[i + 1];
                
                // Simple rectangle check along path segments
                const minX = Math.min(p1.x, p2.x) - 30;
                const maxX = Math.max(p1.x, p2.x) + 30;
                const minY = Math.min(p1.y, p2.y) - 30;
                const maxY = Math.max(p1.y, p2.y) + 30;
                
                if (x >= minX && x <= maxX && y >= minY && y <= maxY) {
                    return false;
                }
            }
            
            // Check if tower already exists at position
            for (let tower of towers) {
                if (Math.abs(tower.x - x) < GRID_SIZE && Math.abs(tower.y - y) < GRID_SIZE) {
                    return false;
                }
            }
            
            return true;
        }

        function showMessage(text, color) {
            particles.push(new Particle(
                canvas.width / 2,
                100,
                text,
                color,
                2000
            ));
        }

        function gameOver() {
            gameState.gameOver = true;
            showMessage('GAME OVER!', '#FF0000');
        }

        // UI Functions
        window.selectTower = function(type) {
            gameState.selectedTower = type;
            gameState.sellModeActive = false;
            
            // Update UI
            document.querySelectorAll('.tower-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            document.querySelector(`[data-tower="${type}"]`).classList.add('active');
        };

        window.startWave = function() {
            if (waveSpawner && !waveSpawner.waveComplete) return;
            
            gameState.wave++;
            waveSpawner = new WaveSpawner(gameState.wave);
            
            // Update wave preview
            updateWavePreview();
        };

        window.pauseGame = function() {
            gameState.paused = !gameState.paused;
        };

        window.speedUp = function() {
            gameState.speed = gameState.speed === 1 ? 2 : 1;
        };

        window.sellMode = function() {
            gameState.sellModeActive = !gameState.sellModeActive;
            gameState.selectedTowerObj = null;
        };

        window.resetGame = function() {
            towers = [];
            enemies = [];
            projectiles = [];
            particles = [];
            waveSpawner = null;
            
            gameState.gold = 500;
            gameState.lives = 20;
            gameState.wave = 0;
            gameState.score = 0;
            gameState.power = 3;
            gameState.gameOver = false;
            
            updateWavePreview();
        };

        window.upgradeTower = function() {
            if (gameState.selectedTowerObj) {
                gameState.selectedTowerObj.upgrade();
                updateTowerInfo();
            }
        };

        window.sellTower = function() {
            if (gameState.selectedTowerObj) {
                const sellPrice = gameState.selectedTowerObj.getSellPrice();
                gameState.gold += sellPrice;
                
                // Remove tower
                const index = towers.indexOf(gameState.selectedTowerObj);
                if (index > -1) {
                    towers.splice(index, 1);
                }
                
                gameState.selectedTowerObj = null;
                document.getElementById('towerInfo').style.display = 'none';
            }
        };

        function updateWavePreview() {
            const nextWave = gameState.wave + 1;
            const waveData = WAVES[Math.min(nextWave - 1, WAVES.length - 1)];
            
            let preview = `Wave ${nextWave}: `;
            waveData.enemies.forEach(group => {
                preview += `${group.count} ${ENEMY_TYPES[group.type].name}, `;
            });
            
            document.getElementById('wavePreview').textContent = preview.slice(0, -2);
        }

        function updateTowerInfo() {
            if (!gameState.selectedTowerObj) return;
            
            const tower = gameState.selectedTowerObj;
            const info = `
                ${tower.stats.name} (Level ${tower.level})<br>
                Damage: ${tower.stats.damage * tower.level}<br>
                Range: ${tower.stats.range}<br>
                Fire Rate: ${tower.stats.fireRate}/s<br>
                Kills: ${tower.kills}<br>
                Upgrade Cost: $${tower.stats.cost * tower.level}
            `;
            
            document.getElementById('towerDetails').innerHTML = info;
        }

        // Input handling
        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            if (gameState.sellModeActive) {
                // Check if clicked on a tower
                for (let tower of towers) {
                    if (Math.abs(tower.x - x) < 15 && Math.abs(tower.y - y) < 15) {
                        gameState.selectedTowerObj = tower;
                        document.getElementById('towerInfo').style.display = 'block';
                        updateTowerInfo();
                        return;
                    }
                }
            } else if (gameState.selectedTower) {
                // Place tower
                placeTower(x, y, gameState.selectedTower);
            } else {
                // Select tower for info
                for (let tower of towers) {
                    if (Math.abs(tower.x - x) < 15 && Math.abs(tower.y - y) < 15) {
                        gameState.selectedTowerObj = tower;
                        document.getElementById('towerInfo').style.display = 'block';
                        updateTowerInfo();
                        return;
                    }
                }
                
                // Deselect if clicked elsewhere
                gameState.selectedTowerObj = null;
                document.getElementById('towerInfo').style.display = 'none';
            }
        });

        // Game loop
        let lastTime = performance.now();
        
        function gameLoop() {
            const currentTime = performance.now();
            const dt = Math.min((currentTime - lastTime) / 1000, 0.1) * gameState.speed;
            lastTime = currentTime;
            
            if (!gameState.paused && !gameState.gameOver) {
                // Update wave spawner
                if (waveSpawner) {
                    waveSpawner.update();
                    
                    // Update progress bar
                    const progress = waveSpawner.getProgress() * 100;
                    document.getElementById('waveBar').style.width = progress + '%';
                    
                    // Check if wave complete and all enemies defeated
                    if (waveSpawner.waveComplete && enemies.filter(e => !e.isDead).length === 0) {
                        waveSpawner = null;
                        document.getElementById('waveBar').style.width = '0%';
                        
                        // Wave complete bonus
                        const bonus = 100 + gameState.wave * 10;
                        gameState.gold += bonus;
                        showMessage(`Wave Complete! +$${bonus}`, '#4CAF50');
                    }
                }
                
                // Update towers
                towers.forEach(tower => tower.update(dt));
                
                // Update enemies
                enemies.forEach(enemy => enemy.update(dt));
                enemies = enemies.filter(e => !e.isDead);
                
                // Update projectiles
                projectiles.forEach(proj => proj.update(dt));
                projectiles = projectiles.filter(p => !p.isDead);
                
                // Update particles
                particles = particles.filter(p => p.update(dt));
            }
            
            // Draw everything
            ctx.fillStyle = '#2d4a2b';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw grid
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.05)';
            ctx.lineWidth = 1;
            for (let x = 0; x < canvas.width; x += GRID_SIZE) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            for (let y = 0; y < canvas.height; y += GRID_SIZE) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
            
            // Draw path
            ctx.strokeStyle = '#8B7355';
            ctx.lineWidth = 40;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.beginPath();
            ctx.moveTo(PATH[0].x, PATH[0].y);
            for (let i = 1; i < PATH.length; i++) {
                ctx.lineTo(PATH[i].x, PATH[i].y);
            }
            ctx.stroke();
            
            // Draw path border
            ctx.strokeStyle = '#654321';
            ctx.lineWidth = 44;
            ctx.beginPath();
            ctx.moveTo(PATH[0].x, PATH[0].y);
            for (let i = 1; i < PATH.length; i++) {
                ctx.lineTo(PATH[i].x, PATH[i].y);
            }
            ctx.stroke();
            
            // Draw towers
            towers.forEach(tower => tower.draw());
            
            // Draw enemies
            enemies.forEach(enemy => enemy.draw());
            
            // Draw projectiles
            projectiles.forEach(proj => proj.draw());
            
            // Draw particles
            particles.forEach(particle => particle.draw());
            
            // Update UI
            document.getElementById('gold').textContent = gameState.gold;
            document.getElementById('lives').textContent = gameState.lives;
            document.getElementById('wave').textContent = gameState.wave;
            document.getElementById('enemies').textContent = enemies.filter(e => !e.isDead).length;
            document.getElementById('tdScore').textContent = gameState.score;
            document.getElementById('power').textContent = gameState.power;
            
            // Game over screen
            if (gameState.gameOver) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                ctx.fillStyle = '#FF0000';
                ctx.font = 'bold 48px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('GAME OVER', canvas.width / 2, canvas.height / 2 - 50);
                
                ctx.fillStyle = '#FFF';
                ctx.font = '24px Arial';
                ctx.fillText(`Final Score: ${gameState.score}`, canvas.width / 2, canvas.height / 2 + 20);
                ctx.fillText(`Waves Survived: ${gameState.wave}`, canvas.width / 2, canvas.height / 2 + 60);
            }
            
            requestAnimationFrame(gameLoop);
        }
        
        // Initialize
        updateWavePreview();
        gameLoop();
        
        console.log('Tower Defense game initialized!');
    </script>

    <h2>Tower Defense Implementation in Python</h2>
    
    <p>For the complete Python implementation with Pygame, see <a href="genres_tower_defense_python.html">the Python tower defense code</a>.</p>

    <h2>Tower Types and Strategies</h2>
    
    <div style="background-color: #f5f5f5; padding: 20px; border-radius: 10px; margin: 20px 0;">
        <h3>🏰 Tower Types</h3>
        <ul>
            <li><strong>Basic Tower:</strong> Balanced damage and fire rate, good against most enemies</li>
            <li><strong>Cannon Tower:</strong> High damage with splash effect, slow fire rate</li>
            <li><strong>Laser Tower:</strong> Instant hit, high fire rate, good against fast enemies</li>
            <li><strong>Slow Tower:</strong> Reduces enemy speed, synergizes with other towers</li>
            <li><strong>Money Tower:</strong> Generates income over time, economic investment</li>
        </ul>
    </div>

    <h2>Enemy Variety</h2>
    
    <div style="background-color: #fff9e6; padding: 20px; border-radius: 10px; margin: 20px 0;">
        <h3>👾 Enemy Types</h3>
        <ul>
            <li><strong>Basic:</strong> Standard health and speed</li>
            <li><strong>Fast:</strong> Low health but high speed</li>
            <li><strong>Tank:</strong> High health and armor, slow movement</li>
            <li><strong>Flying:</strong> Can only be hit by certain towers</li>
            <li><strong>Boss:</strong> Extremely high health, appears in later waves</li>
        </ul>
    </div>

    <h2>Wave System Design</h2>
    
    <div style="background-color: #f0fff0; padding: 20px; border-radius: 10px; margin: 20px 0;">
        <h3>🌊 Wave Mechanics</h3>
        <pre><code class="language-javascript">
// Wave composition
const wave = {
    number: 5,
    enemies: [
        { type: 'basic', count: 20, spacing: 600 },
        { type: 'tank', count: 3, spacing: 1500 }
    ],
    bonus: 100,
    difficulty_multiplier: 1.1
};

// Enemy health scaling
enemy.health = base_health * Math.pow(1.1, wave_number);

// Wave reward calculation
wave_reward = base_reward + (wave_number * 10);

// Spawn timing
spawn_delay = base_delay / (1 + wave_number * 0.05);
        </code></pre>
    </div>

    <h2>Economy Balance</h2>
    
    <div style="background-color: #fff0f5; padding: 20px; border-radius: 10px; margin: 20px 0;">
        <h3>💰 Resource Management</h3>
        <ul>
            <li><strong>Starting Gold:</strong> Enough for 3-5 basic towers</li>
            <li><strong>Enemy Rewards:</strong> Scale with difficulty</li>
            <li><strong>Tower Costs:</strong> Exponential upgrade pricing</li>
            <li><strong>Sell Value:</strong> 70% of total investment</li>
            <li><strong>Income Generation:</strong> Passive income from money towers</li>
            <li><strong>Wave Bonuses:</strong> Reward for perfect defense</li>
        </ul>
    </div>

    <h2>Advanced Strategies</h2>
    
    <div style="background-color: #f3e5f5; padding: 20px; border-radius: 10px; margin: 20px 0;">
        <h3>🎯 Pro Tips</h3>
        <ul>
            <li><strong>Maze Building:</strong> Force enemies to take longer paths</li>
            <li><strong>Kill Zones:</strong> Concentrate firepower at choke points</li>
            <li><strong>Tower Synergy:</strong> Combine slow + damage dealers</li>
            <li><strong>Economic Balance:</strong> Invest in money towers early</li>
            <li><strong>Upgrade vs Quantity:</strong> Few upgraded towers beat many weak ones</li>
            <li><strong>Target Priority:</strong> Focus on enemies closest to exit</li>
        </ul>
    </div>

    <h2>Best Practices</h2>
    
    <div style="background-color: #fff3e0; padding: 20px; border-radius: 10px; margin: 20px 0;">
        <h3>✨ Tower Defense Best Practices</h3>
        <ul>
            <li><strong>Clear Visual Feedback:</strong> Show range, damage, and effects clearly</li>
            <li><strong>Predictable Pathing:</strong> Players should understand enemy movement</li>
            <li><strong>Meaningful Choices:</strong> Each tower type should have a purpose</li>
            <li><strong>Progressive Difficulty:</strong> Smooth difficulty curve with spikes</li>
            <li><strong>Resource Tension:</strong> Force economic decisions</li>
            <li><strong>Upgrade Paths:</strong> Multiple viable strategies</li>
            <li><strong>Special Abilities:</strong> Active player engagement beyond placement</li>
            <li><strong>Performance:</strong> Handle hundreds of entities smoothly</li>
        </ul>
    </div>

    <h2>Key Takeaways</h2>
    
    <div style="background-color: #f0f8ff; padding: 20px; border-radius: 10px; margin: 20px 0;">
        <ul>
            <li>🏰 Tower variety creates strategic depth</li>
            <li>👾 Enemy diversity requires adaptation</li>
            <li>🌊 Wave systems provide pacing and tension</li>
            <li>💰 Economy management adds resource strategy</li>
            <li>🎯 Targeting AI affects effectiveness</li>
            <li>📈 Upgrade systems provide progression</li>
            <li>🗺️ Map design influences strategy</li>
            <li>⚡ Special abilities add active gameplay</li>
        </ul>
    </div>

    <h2>What's Next?</h2>
    
    <p>Congratulations on completing the game genres section! You've learned puzzle mechanics, racing physics, and tower defense patterns. Continue exploring other advanced topics in game development!</p>

    <!-- Lesson Navigation -->
    <nav class="lesson-nav" aria-label="Lesson navigation">
        <a href="genres_racing.html" class="prev-lesson">Previous: Racing Game Physics</a>
        <a href="index.html" class="next-lesson">Back to Course Home</a>
    </nav>
    
    </main>
</body>
</html>