<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Learn socket programming for game networking. Master TCP/UDP protocols, socket creation, and real-time communication.">
    <title>Socket Programming - Multiplayer Basics</title>
    <link rel="stylesheet" href="styles/main.css">
    <link rel="stylesheet" href="styles/enhanced.css">
    <link rel="icon" href="favicon.png">
    <script type="module">
      import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
      mermaid.initialize({ startOnLoad: true });
    </script>
    <script src="/js/clipboard.js" defer></script>
</head>
<body>
    <!-- Skip to main content for accessibility -->
    <a href="#main-content" class="skip-to-main">Skip to main content</a>
    
    <!-- Progress indicator -->
    <div class="progress-indicator" role="progressbar" aria-label="Page scroll progress">
        <div class="progress-bar"></div>
    </div>
    
    <main id="main-content">
    <header role="banner">
        <h1>Socket Programming</h1>
        <div class="reading-time" aria-label="Estimated reading time">25 minute read</div>
    </header>
    
    <!-- Breadcrumb Navigation -->
    <nav class="breadcrumb" aria-label="Breadcrumb">
        <a href="index.html">Course Home</a>
        <span class="separator">‚Ä∫</span>
        <span class="current">Intermediate Module - Section 4: Multiplayer Basics - Lesson 3</span>
    </nav>

    <h2>Building Network Communication for Games</h2>
    
    <div style="background-color: #f0f8ff; padding: 20px; border-radius: 10px; margin: 20px 0;">
        <p>Master the fundamentals of socket programming! Learn how to create networked games using TCP and UDP protocols, implement real-time communication, and handle multiple clients! üåêüéÆüîå</p>
    </div>

    <h2>Understanding Sockets</h2>
    
    <div style="background-color: #fff5f5; padding: 20px; border-radius: 10px; margin: 20px 0;">
        <h3>üîå What Are Sockets?</h3>
        <p>A socket is an endpoint for network communication. Think of it as a telephone - you need one on each end to have a conversation!</p>
        <ul>
            <li><strong>IP Address:</strong> The "phone number" - identifies the computer</li>
            <li><strong>Port:</strong> The "extension" - identifies the specific application</li>
            <li><strong>Protocol:</strong> The "language" - how data is formatted (TCP or UDP)</li>
            <li><strong>Socket:</strong> The combination of IP + Port + Protocol</li>
        </ul>
    </div>

    <div class="mermaid">
    graph LR
        A["Client Socket<br/>192.168.1.100:5000"] -->|"Data Flow"| B["Server Socket<br/>192.168.1.50:8080"]
        B -->|"Response"| A
        
        C["Client Process"] --> A
        B --> D["Server Process"]
        
        style A fill:#e1f5fe
        style B fill:#fff3e0
        style C fill:#c8e6c9
        style D fill:#ffccbc
    </div>

    <h2>TCP vs UDP</h2>
    
    <div style="background-color: #f9f9f9; padding: 20px; border-radius: 10px; margin: 20px 0;">
        <h3>üì° Choosing the Right Protocol</h3>
        
        <table style="width: 100%; border-collapse: collapse;">
            <tr style="background-color: #333; color: white;">
                <th style="padding: 10px;">Aspect</th>
                <th style="padding: 10px;">TCP</th>
                <th style="padding: 10px;">UDP</th>
            </tr>
            <tr>
                <td style="padding: 10px; border: 1px solid #ddd;"><strong>Connection</strong></td>
                <td style="padding: 10px; border: 1px solid #ddd;">Connection-oriented</td>
                <td style="padding: 10px; border: 1px solid #ddd;">Connectionless</td>
            </tr>
            <tr>
                <td style="padding: 10px; border: 1px solid #ddd;"><strong>Reliability</strong></td>
                <td style="padding: 10px; border: 1px solid #ddd;">Guaranteed delivery</td>
                <td style="padding: 10px; border: 1px solid #ddd;">No guarantee</td>
            </tr>
            <tr>
                <td style="padding: 10px; border: 1px solid #ddd;"><strong>Order</strong></td>
                <td style="padding: 10px; border: 1px solid #ddd;">Ordered packets</td>
                <td style="padding: 10px; border: 1px solid #ddd;">May arrive out of order</td>
            </tr>
            <tr>
                <td style="padding: 10px; border: 1px solid #ddd;"><strong>Speed</strong></td>
                <td style="padding: 10px; border: 1px solid #ddd;">Slower</td>
                <td style="padding: 10px; border: 1px solid #ddd;">Faster</td>
            </tr>
            <tr>
                <td style="padding: 10px; border: 1px solid #ddd;"><strong>Use in Games</strong></td>
                <td style="padding: 10px; border: 1px solid #ddd;">Turn-based, chat, login</td>
                <td style="padding: 10px; border: 1px solid #ddd;">Real-time action, position updates</td>
            </tr>
        </table>
    </div>

    <h2>Basic TCP Socket Implementation</h2>
    
    <div style="background-color: #f0fff0; padding: 20px; border-radius: 10px; margin: 20px 0;">
        <h3>üîß TCP Server and Client</h3>
        
        <h4>TCP Server</h4>
        <pre><code class="language-python">
import socket
import threading
import json

class GameServer:
    def __init__(self, host='localhost', port=5555):
        self.host = host
        self.port = port
        self.server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.clients = {}  # {client_socket: player_data}
        self.running = False
        
    def start(self):
        """Start the server"""
        # Allow reuse of address
        self.server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        
        # Bind to address and port
        self.server.bind((self.host, self.port))
        
        # Listen for connections (max 5 queued)
        self.server.listen(5)
        self.running = True
        
        print(f"Server listening on {self.host}:{self.port}")
        
        # Accept connections in a loop
        while self.running:
            try:
                client_socket, address = self.server.accept()
                print(f"New connection from {address}")
                
                # Handle each client in a separate thread
                client_thread = threading.Thread(
                    target=self.handle_client,
                    args=(client_socket, address)
                )
                client_thread.start()
                
            except Exception as e:
                print(f"Error accepting connection: {e}")
    
    def handle_client(self, client_socket, address):
        """Handle individual client connection"""
        # Initialize player data
        player_id = f"player_{len(self.clients)}"
        self.clients[client_socket] = {
            'id': player_id,
            'address': address,
            'x': 100,
            'y': 100,
            'score': 0
        }
        
        # Send welcome message
        welcome_msg = {
            'type': 'welcome',
            'player_id': player_id,
            'message': 'Connected to game server!'
        }
        self.send_to_client(client_socket, welcome_msg)
        
        # Broadcast new player to others
        self.broadcast({
            'type': 'player_joined',
            'player_id': player_id
        }, exclude=client_socket)
        
        # Main client loop
        while self.running:
            try:
                # Receive data (max 4096 bytes)
                data = client_socket.recv(4096).decode('utf-8')
                
                if not data:
                    break
                
                # Parse JSON message
                message = json.loads(data)
                self.process_message(client_socket, message)
                
            except ConnectionResetError:
                print(f"Client {address} disconnected abruptly")
                break
            except json.JSONDecodeError:
                print(f"Invalid JSON from {address}")
            except Exception as e:
                print(f"Error handling client {address}: {e}")
                break
        
        # Clean up on disconnect
        self.remove_client(client_socket)
    
    def process_message(self, client_socket, message):
        """Process incoming message from client"""
        msg_type = message.get('type')
        player = self.clients[client_socket]
        
        if msg_type == 'move':
            # Update player position
            player['x'] = message.get('x', player['x'])
            player['y'] = message.get('y', player['y'])
            
            # Broadcast position to all clients
            self.broadcast({
                'type': 'player_moved',
                'player_id': player['id'],
                'x': player['x'],
                'y': player['y']
            })
            
        elif msg_type == 'chat':
            # Broadcast chat message
            self.broadcast({
                'type': 'chat',
                'player_id': player['id'],
                'message': message.get('message', '')
            })
            
        elif msg_type == 'get_players':
            # Send list of all players
            players_list = [
                {
                    'id': p['id'],
                    'x': p['x'],
                    'y': p['y'],
                    'score': p['score']
                }
                for p in self.clients.values()
            ]
            self.send_to_client(client_socket, {
                'type': 'players_list',
                'players': players_list
            })
    
    def send_to_client(self, client_socket, message):
        """Send message to specific client"""
        try:
            json_msg = json.dumps(message)
            client_socket.send(json_msg.encode('utf-8'))
        except Exception as e:
            print(f"Error sending to client: {e}")
    
    def broadcast(self, message, exclude=None):
        """Broadcast message to all clients"""
        json_msg = json.dumps(message)
        
        for client_socket in list(self.clients.keys()):
            if client_socket != exclude:
                try:
                    client_socket.send(json_msg.encode('utf-8'))
                except:
                    # Remove dead connections
                    self.remove_client(client_socket)
    
    def remove_client(self, client_socket):
        """Remove client from server"""
        if client_socket in self.clients:
            player_id = self.clients[client_socket]['id']
            del self.clients[client_socket]
            
            # Notify others
            self.broadcast({
                'type': 'player_left',
                'player_id': player_id
            })
            
            client_socket.close()
            print(f"Client {player_id} disconnected")
    
    def stop(self):
        """Stop the server"""
        self.running = False
        for client in list(self.clients.keys()):
            client.close()
        self.server.close()

# TCP Client
class GameClient:
    def __init__(self):
        self.socket = None
        self.connected = False
        self.player_id = None
        self.receive_thread = None
        
    def connect(self, host='localhost', port=5555):
        """Connect to game server"""
        try:
            self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            self.socket.connect((host, port))
            self.connected = True
            
            # Start receiving thread
            self.receive_thread = threading.Thread(target=self.receive_loop)
            self.receive_thread.daemon = True
            self.receive_thread.start()
            
            print(f"Connected to {host}:{port}")
            return True
            
        except Exception as e:
            print(f"Failed to connect: {e}")
            return False
    
    def receive_loop(self):
        """Continuously receive messages from server"""
        while self.connected:
            try:
                data = self.socket.recv(4096).decode('utf-8')
                if not data:
                    break
                    
                message = json.loads(data)
                self.handle_message(message)
                
            except Exception as e:
                print(f"Receive error: {e}")
                break
        
        self.disconnect()
    
    def handle_message(self, message):
        """Handle incoming message from server"""
        msg_type = message.get('type')
        
        if msg_type == 'welcome':
            self.player_id = message.get('player_id')
            print(f"Assigned ID: {self.player_id}")
            print(message.get('message'))
            
        elif msg_type == 'player_joined':
            print(f"Player {message.get('player_id')} joined the game")
            
        elif msg_type == 'player_left':
            print(f"Player {message.get('player_id')} left the game")
            
        elif msg_type == 'player_moved':
            player_id = message.get('player_id')
            x = message.get('x')
            y = message.get('y')
            print(f"Player {player_id} moved to ({x}, {y})")
            
        elif msg_type == 'chat':
            player_id = message.get('player_id')
            chat_msg = message.get('message')
            print(f"[{player_id}]: {chat_msg}")
    
    def send_message(self, message):
        """Send message to server"""
        if self.connected and self.socket:
            try:
                json_msg = json.dumps(message)
                self.socket.send(json_msg.encode('utf-8'))
                return True
            except Exception as e:
                print(f"Send error: {e}")
                return False
        return False
    
    def move(self, x, y):
        """Send movement update"""
        return self.send_message({
            'type': 'move',
            'x': x,
            'y': y
        })
    
    def chat(self, message):
        """Send chat message"""
        return self.send_message({
            'type': 'chat',
            'message': message
        })
    
    def disconnect(self):
        """Disconnect from server"""
        self.connected = False
        if self.socket:
            self.socket.close()
            print("Disconnected from server")

# Example usage
if __name__ == "__main__":
    import sys
    
    if len(sys.argv) > 1 and sys.argv[1] == 'server':
        # Run as server
        server = GameServer()
        try:
            server.start()
        except KeyboardInterrupt:
            print("\nShutting down server...")
            server.stop()
    else:
        # Run as client
        client = GameClient()
        if client.connect():
            # Simple command loop
            while client.connected:
                try:
                    cmd = input("Enter command (move x y, chat msg, quit): ")
                    parts = cmd.split(' ', 2)
                    
                    if parts[0] == 'quit':
                        break
                    elif parts[0] == 'move' and len(parts) >= 3:
                        x = int(parts[1])
                        y = int(parts[2])
                        client.move(x, y)
                    elif parts[0] == 'chat' and len(parts) >= 2:
                        client.chat(parts[1])
                    
                except KeyboardInterrupt:
                    break
                except Exception as e:
                    print(f"Error: {e}")
            
            client.disconnect()
        </code></pre>
    </div>

    <h2>UDP Socket Implementation</h2>
    
    <div style="background-color: #fff9e6; padding: 20px; border-radius: 10px; margin: 20px 0;">
        <h3>‚ö° UDP for Real-Time Games</h3>
        
        <pre><code class="language-python">
import socket
import json
import time
import struct
import threading

class UDPGameServer:
    def __init__(self, host='localhost', port=5556):
        self.host = host
        self.port = port
        self.socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        self.clients = {}  # {address: {last_seen, player_data}}
        self.running = False
        self.sequence_number = 0
        
    def start(self):
        """Start UDP server"""
        self.socket.bind((self.host, self.port))
        self.running = True
        
        print(f"UDP Server listening on {self.host}:{self.port}")
        
        # Start cleanup thread
        cleanup_thread = threading.Thread(target=self.cleanup_inactive_clients)
        cleanup_thread.daemon = True
        cleanup_thread.start()
        
        # Main receive loop
        while self.running:
            try:
                # Receive datagram
                data, address = self.socket.recvfrom(1024)
                
                # Process in separate thread for non-blocking
                threading.Thread(
                    target=self.handle_packet,
                    args=(data, address)
                ).start()
                
            except Exception as e:
                print(f"Error receiving packet: {e}")
    
    def handle_packet(self, data, address):
        """Handle incoming UDP packet"""
        try:
            # Parse packet
            message = json.loads(data.decode('utf-8'))
            
            # Update client last seen time
            if address not in self.clients:
                # New client
                player_id = f"player_{len(self.clients)}"
                self.clients[address] = {
                    'last_seen': time.time(),
                    'player_id': player_id,
                    'x': 100,
                    'y': 100,
                    'vx': 0,
                    'vy': 0,
                    'sequence': 0
                }
                
                # Send acknowledgment
                self.send_to_client(address, {
                    'type': 'connected',
                    'player_id': player_id
                })
                
                print(f"New UDP client: {address}")
            else:
                self.clients[address]['last_seen'] = time.time()
            
            # Process message
            self.process_packet(address, message)
            
        except json.JSONDecodeError:
            print(f"Invalid JSON from {address}")
        except Exception as e:
            print(f"Error handling packet: {e}")
    
    def process_packet(self, address, message):
        """Process UDP message"""
        client = self.clients[address]
        msg_type = message.get('type')
        
        # Check sequence number for ordering
        seq = message.get('sequence', 0)
        if seq <= client['sequence'] and msg_type != 'ping':
            return  # Ignore old packets
        client['sequence'] = seq
        
        if msg_type == 'update':
            # Position update
            client['x'] = message.get('x', client['x'])
            client['y'] = message.get('y', client['y'])
            client['vx'] = message.get('vx', 0)
            client['vy'] = message.get('vy', 0)
            
            # Broadcast state to all clients
            self.broadcast_state()
            
        elif msg_type == 'ping':
            # Respond to ping
            self.send_to_client(address, {
                'type': 'pong',
                'timestamp': message.get('timestamp', time.time())
            })
    
    def broadcast_state(self):
        """Broadcast game state to all clients"""
        # Prepare state snapshot
        state = {
            'type': 'state',
            'timestamp': time.time(),
            'sequence': self.sequence_number,
            'players': []
        }
        
        for addr, client in self.clients.items():
            state['players'].append({
                'id': client['player_id'],
                'x': client['x'],
                'y': client['y'],
                'vx': client['vx'],
                'vy': client['vy']
            })
        
        # Send to all clients
        for address in self.clients.keys():
            self.send_to_client(address, state)
        
        self.sequence_number += 1
    
    def send_to_client(self, address, message):
        """Send message to specific client"""
        try:
            data = json.dumps(message).encode('utf-8')
            self.socket.sendto(data, address)
        except Exception as e:
            print(f"Error sending to {address}: {e}")
    
    def cleanup_inactive_clients(self):
        """Remove inactive clients"""
        while self.running:
            time.sleep(5)  # Check every 5 seconds
            current_time = time.time()
            
            # Remove clients inactive for 10+ seconds
            inactive = []
            for address, client in self.clients.items():
                if current_time - client['last_seen'] > 10:
                    inactive.append(address)
            
            for address in inactive:
                print(f"Removing inactive client: {address}")
                del self.clients[address]
    
    def stop(self):
        """Stop server"""
        self.running = False
        self.socket.close()

class UDPGameClient:
    def __init__(self):
        self.socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        self.server_address = None
        self.player_id = None
        self.sequence_number = 0
        self.last_ping = 0
        self.latency = 0
        self.running = False
        
    def connect(self, host='localhost', port=5556):
        """Connect to UDP server"""
        self.server_address = (host, port)
        self.running = True
        
        # Start receive thread
        receive_thread = threading.Thread(target=self.receive_loop)
        receive_thread.daemon = True
        receive_thread.start()
        
        # Send initial connection packet
        self.send_message({'type': 'connect'})
        
        # Start ping thread
        ping_thread = threading.Thread(target=self.ping_loop)
        ping_thread.daemon = True
        ping_thread.start()
        
        print(f"Connecting to UDP server at {host}:{port}")
        return True
    
    def receive_loop(self):
        """Receive packets from server"""
        while self.running:
            try:
                data, address = self.socket.recvfrom(1024)
                message = json.loads(data.decode('utf-8'))
                self.handle_message(message)
                
            except Exception as e:
                print(f"Receive error: {e}")
    
    def handle_message(self, message):
        """Handle server message"""
        msg_type = message.get('type')
        
        if msg_type == 'connected':
            self.player_id = message.get('player_id')
            print(f"Connected as {self.player_id}")
            
        elif msg_type == 'state':
            # Game state update
            players = message.get('players', [])
            for player in players:
                if player['id'] != self.player_id:
                    # Update other players
                    print(f"Player {player['id']}: ({player['x']}, {player['y']})")
            
        elif msg_type == 'pong':
            # Calculate latency
            self.latency = (time.time() - message.get('timestamp', 0)) * 1000
            print(f"Latency: {self.latency:.1f}ms")
    
    def send_message(self, message):
        """Send message to server"""
        if self.server_address:
            try:
                message['sequence'] = self.sequence_number
                self.sequence_number += 1
                
                data = json.dumps(message).encode('utf-8')
                self.socket.sendto(data, self.server_address)
                return True
                
            except Exception as e:
                print(f"Send error: {e}")
                return False
        return False
    
    def send_position(self, x, y, vx=0, vy=0):
        """Send position update"""
        return self.send_message({
            'type': 'update',
            'x': x,
            'y': y,
            'vx': vx,
            'vy': vy
        })
    
    def ping_loop(self):
        """Send periodic pings to measure latency"""
        while self.running:
            time.sleep(1)  # Ping every second
            self.send_message({
                'type': 'ping',
                'timestamp': time.time()
            })
    
    def disconnect(self):
        """Disconnect from server"""
        self.running = False
        self.socket.close()
        print("Disconnected")
        </code></pre>
    </div>

    <h2>Game Integration Example</h2>
    
    <div style="background-color: #f3e5f5; padding: 20px; border-radius: 10px; margin: 20px 0;">
        <h3>üéÆ Pygame Network Game</h3>
        
        <pre><code class="language-python">
import pygame
import threading
from game_client import GameClient  # Our TCP client from above

class NetworkedGame:
    def __init__(self):
        pygame.init()
        self.screen = pygame.display.set_mode((800, 600))
        pygame.display.set_caption("Networked Game")
        self.clock = pygame.time.Clock()
        
        # Network client
        self.client = GameClient()
        self.connected = False
        
        # Game state
        self.players = {}  # {player_id: {'x': x, 'y': y, 'color': color}}
        self.my_player = None
        
        # Connect to server
        self.connect_to_server()
    
    def connect_to_server(self):
        """Connect to game server"""
        if self.client.connect('localhost', 5555):
            self.connected = True
            
            # Override client's message handler
            self.client.handle_message = self.handle_network_message
            
            print("Connected to server!")
        else:
            print("Failed to connect to server")
    
    def handle_network_message(self, message):
        """Handle messages from server"""
        msg_type = message.get('type')
        
        if msg_type == 'welcome':
            # Create our player
            player_id = message.get('player_id')
            self.my_player = player_id
            self.players[player_id] = {
                'x': 400,
                'y': 300,
                'color': (0, 255, 0)  # Green for our player
            }
            
        elif msg_type == 'player_joined':
            # Add new player
            player_id = message.get('player_id')
            if player_id not in self.players:
                self.players[player_id] = {
                    'x': 100,
                    'y': 100,
                    'color': (255, 0, 0)  # Red for others
                }
            
        elif msg_type == 'player_left':
            # Remove player
            player_id = message.get('player_id')
            if player_id in self.players:
                del self.players[player_id]
            
        elif msg_type == 'player_moved':
            # Update player position
            player_id = message.get('player_id')
            if player_id in self.players:
                self.players[player_id]['x'] = message.get('x')
                self.players[player_id]['y'] = message.get('y')
            
        elif msg_type == 'players_list':
            # Sync all players
            for player_data in message.get('players', []):
                player_id = player_data['id']
                if player_id not in self.players:
                    color = (0, 255, 0) if player_id == self.my_player else (255, 0, 0)
                    self.players[player_id] = {
                        'x': player_data['x'],
                        'y': player_data['y'],
                        'color': color
                    }
    
    def run(self):
        """Main game loop"""
        running = True
        
        while running:
            dt = self.clock.tick(60) / 1000.0  # 60 FPS
            
            # Handle events
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    running = False
                elif event.type == pygame.KEYDOWN:
                    if event.key == pygame.K_SPACE:
                        # Request player list
                        self.client.send_message({'type': 'get_players'})
            
            # Handle input
            if self.connected and self.my_player:
                keys = pygame.key.get_pressed()
                player = self.players.get(self.my_player)
                
                if player:
                    moved = False
                    speed = 200  # pixels per second
                    
                    if keys[pygame.K_LEFT]:
                        player['x'] -= speed * dt
                        moved = True
                    if keys[pygame.K_RIGHT]:
                        player['x'] += speed * dt
                        moved = True
                    if keys[pygame.K_UP]:
                        player['y'] -= speed * dt
                        moved = True
                    if keys[pygame.K_DOWN]:
                        player['y'] += speed * dt
                        moved = True
                    
                    # Keep player on screen
                    player['x'] = max(20, min(780, player['x']))
                    player['y'] = max(20, min(580, player['y']))
                    
                    # Send position to server
                    if moved:
                        self.client.move(int(player['x']), int(player['y']))
            
            # Draw everything
            self.screen.fill((30, 30, 30))
            
            # Draw players
            for player_id, player_data in self.players.items():
                x = int(player_data['x'])
                y = int(player_data['y'])
                color = player_data['color']
                
                # Draw player circle
                pygame.draw.circle(self.screen, color, (x, y), 20)
                
                # Draw player ID
                font = pygame.font.Font(None, 24)
                text = font.render(player_id, True, (255, 255, 255))
                text_rect = text.get_rect(center=(x, y - 30))
                self.screen.blit(text, text_rect)
            
            # Draw connection status
            status_color = (0, 255, 0) if self.connected else (255, 0, 0)
            status_text = "Connected" if self.connected else "Disconnected"
            font = pygame.font.Font(None, 36)
            text = font.render(status_text, True, status_color)
            self.screen.blit(text, (10, 10))
            
            # Draw instructions
            font = pygame.font.Font(None, 24)
            instructions = [
                "Arrow Keys: Move",
                "Space: Sync Players",
                "ESC: Quit"
            ]
            for i, instruction in enumerate(instructions):
                text = font.render(instruction, True, (200, 200, 200))
                self.screen.blit(text, (10, 550 + i * 20))
            
            pygame.display.flip()
        
        # Clean up
        if self.connected:
            self.client.disconnect()
        pygame.quit()

if __name__ == "__main__":
    game = NetworkedGame()
    game.run()
        </code></pre>
    </div>

    <h2>Advanced Socket Concepts</h2>
    
    <div style="background-color: #e8f5e9; padding: 20px; border-radius: 10px; margin: 20px 0;">
        <h3>üî¨ Advanced Techniques</h3>
        
        <h4>1. Non-blocking Sockets</h4>
        <pre><code class="language-python">
import socket
import select

# Make socket non-blocking
sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
sock.setblocking(False)

# Use select for multiplexing
readable, writable, errors = select.select([sock], [], [], timeout=0.1)
if readable:
    data = sock.recv(1024)
        </code></pre>
        
        <h4>2. Message Framing</h4>
        <pre><code class="language-python">
def send_message_with_length(sock, message):
    """Send message with length prefix"""
    data = message.encode('utf-8')
    length = len(data)
    
    # Send 4-byte length prefix
    sock.send(struct.pack('!I', length))
    # Send actual data
    sock.send(data)

def receive_message_with_length(sock):
    """Receive message with length prefix"""
    # Receive length prefix
    length_data = sock.recv(4)
    if not length_data:
        return None
    
    length = struct.unpack('!I', length_data)[0]
    
    # Receive exact amount of data
    data = b''
    while len(data) < length:
        chunk = sock.recv(min(4096, length - len(data)))
        if not chunk:
            return None
        data += chunk
    
    return data.decode('utf-8')
        </code></pre>
        
        <h4>3. Connection Pooling</h4>
        <pre><code class="language-python">
class ConnectionPool:
    def __init__(self, max_connections=10):
        self.pool = []
        self.max_connections = max_connections
        
    def get_connection(self, host, port):
        # Reuse existing connection if available
        for conn in self.pool:
            if not conn.in_use:
                conn.in_use = True
                return conn
        
        # Create new connection if under limit
        if len(self.pool) < self.max_connections:
            conn = self.create_connection(host, port)
            self.pool.append(conn)
            return conn
        
        return None  # Pool exhausted
        </code></pre>
    </div>

    <h2>Security Considerations</h2>
    
    <div style="background-color: #fff0f5; padding: 20px; border-radius: 10px; margin: 20px 0;">
        <h3>üîí Socket Security</h3>
        <ul>
            <li><strong>Input Validation:</strong> Always validate incoming data</li>
            <li><strong>Buffer Limits:</strong> Set maximum message sizes</li>
            <li><strong>Rate Limiting:</strong> Prevent spam/DoS attacks</li>
            <li><strong>Encryption:</strong> Use SSL/TLS for sensitive data</li>
            <li><strong>Authentication:</strong> Verify client identities</li>
            <li><strong>Timeout Handling:</strong> Set socket timeouts</li>
        </ul>
        
        <pre><code class="language-python">
# Example: Rate limiting
class RateLimiter:
    def __init__(self, max_requests=10, time_window=1.0):
        self.max_requests = max_requests
        self.time_window = time_window
        self.clients = {}  # {address: [timestamps]}
    
    def is_allowed(self, address):
        current_time = time.time()
        
        if address not in self.clients:
            self.clients[address] = []
        
        # Remove old timestamps
        self.clients[address] = [
            t for t in self.clients[address] 
            if current_time - t < self.time_window
        ]
        
        # Check rate limit
        if len(self.clients[address]) < self.max_requests:
            self.clients[address].append(current_time)
            return True
        
        return False
        </code></pre>
    </div>

    <h2>Debugging Network Code</h2>
    
    <div style="background-color: #f5f5f5; padding: 20px; border-radius: 10px; margin: 20px 0;">
        <h3>üêõ Debugging Tools and Tips</h3>
        
        <h4>1. Packet Logging</h4>
        <pre><code class="language-python">
import logging

logging.basicConfig(level=logging.DEBUG,
                   format='%(asctime)s - %(levelname)s - %(message)s')

def log_packet(direction, address, data):
    logging.debug(f"{direction} {address}: {data[:100]}")  # First 100 chars
        </code></pre>
        
        <h4>2. Network Monitoring Tools</h4>
        <ul>
            <li><strong>Wireshark:</strong> Packet analysis</li>
            <li><strong>netstat:</strong> View active connections</li>
            <li><strong>tcpdump:</strong> Command-line packet capture</li>
            <li><strong>telnet:</strong> Test TCP connections</li>
            <li><strong>nc (netcat):</strong> Swiss army knife for networking</li>
        </ul>
        
        <h4>3. Common Issues</h4>
        <ul>
            <li><strong>Connection Refused:</strong> Server not running or wrong port</li>
            <li><strong>Address Already in Use:</strong> Port still bound from previous run</li>
            <li><strong>Firewall Blocking:</strong> Check firewall rules</li>
            <li><strong>Data Corruption:</strong> Encoding/decoding issues</li>
            <li><strong>Deadlocks:</strong> Improper threading</li>
        </ul>
    </div>

    <h2>Best Practices</h2>
    
    <div style="background-color: #fff3e0; padding: 20px; border-radius: 10px; margin: 20px 0;">
        <h3>‚ú® Socket Programming Best Practices</h3>
        <ul>
            <li><strong>Protocol Design:</strong> Define clear message formats</li>
            <li><strong>Error Handling:</strong> Always handle network errors gracefully</li>
            <li><strong>Resource Cleanup:</strong> Always close sockets properly</li>
            <li><strong>Threading Safety:</strong> Use locks for shared resources</li>
            <li><strong>Buffer Management:</strong> Don't assume message boundaries</li>
            <li><strong>Timeouts:</strong> Set appropriate timeouts for operations</li>
            <li><strong>Testing:</strong> Test with packet loss and high latency</li>
            <li><strong>Documentation:</strong> Document your protocol</li>
            <li><strong>Versioning:</strong> Plan for protocol changes</li>
            <li><strong>Monitoring:</strong> Log important events</li>
        </ul>
    </div>

    <h2>Key Takeaways</h2>
    
    <div style="background-color: #f0f8ff; padding: 20px; border-radius: 10px; margin: 20px 0;">
        <ul>
            <li>üîå Sockets are the foundation of network communication</li>
            <li>üì° Choose TCP for reliability, UDP for speed</li>
            <li>üîÑ Always handle network errors and disconnections</li>
            <li>üì¶ Frame your messages properly for TCP</li>
            <li>‚è±Ô∏è Implement timeouts and cleanup inactive connections</li>
            <li>üîí Validate all incoming data for security</li>
            <li>üßµ Use threading for handling multiple clients</li>
            <li>üìä Monitor and log network activity for debugging</li>
        </ul>
    </div>

    <h2>What's Next?</h2>
    
    <p>Now that you understand socket programming, let's learn about handling lag and latency in networked games!</p>

    <!-- Lesson Navigation -->
    <nav class="lesson-nav" aria-label="Lesson navigation">
        <a href="networking_client_server.html" class="prev-lesson">Previous: Client-Server Architecture</a>
        <a href="networking_lag_compensation.html" class="next-lesson">Next: Handling Lag/Latency</a>
    </nav>
    
    </main>
</body>
</html>