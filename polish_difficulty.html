<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Master difficulty balancing for games. Learn difficulty curves, dynamic difficulty adjustment, player skill modeling, and creating engaging challenges.">
    <title>Difficulty Balancing - Game Polish & Feel</title>
    <link rel="stylesheet" href="/styles/main.css">
    <link rel="stylesheet" href="/styles/enhanced.css">
    <link rel="icon" href="/favicon.png">
    <script type="module">
      import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
      mermaid.initialize({ startOnLoad: true });
    </script>
</head>
<body>
    <!-- Skip to main content for accessibility -->
    <a href="#main-content" class="skip-to-main">Skip to main content</a>
    
    <!-- Progress indicator -->
    <div class="progress-indicator" role="progressbar" aria-label="Page scroll progress">
        <div class="progress-bar"></div>
    </div>
    
    <main id="main-content">
    <header role="banner">
        <h1>Difficulty Balancing</h1>
        <div class="reading-time" aria-label="Estimated reading time"></div>
    </header>
    
    <!-- Breadcrumb Navigation -->
    <nav class="breadcrumb" aria-label="Breadcrumb">
        <a href="index.html">Course Home</a>
        <span class="separator">›</span>
        <span class="current">Advanced Module - Section 2: Game Polish & Feel - Lesson 4</span>
    </nav>

    <h2>Creating the Perfect Challenge</h2>
    
    <div style="background-color: #f0f8ff; padding: 20px; border-radius: 10px; margin: 20px 0;">
        <p>Design games that challenge without frustrating! Master difficulty curves, dynamic adjustment, flow state mechanics, and create experiences that adapt to every player's skill level! 📈🎯🏆</p>
    </div>

    <h2>Understanding Difficulty</h2>
    
    <div style="background-color: #fff5f5; padding: 20px; border-radius: 10px; margin: 20px 0;">
        <h3>📈 The Learning Curve Analogy</h3>
        <p>Think of difficulty like teaching someone to ride a bike:</p>
        <ul>
            <li><strong>Onboarding:</strong> Training wheels (tutorials)</li>
            <li><strong>Skill Building:</strong> Gradual challenge increase</li>
            <li><strong>Flow State:</strong> Perfect balance of challenge/skill</li>
            <li><strong>Frustration:</strong> Too hard, player quits</li>
            <li><strong>Boredom:</strong> Too easy, player loses interest</li>
            <li><strong>Mastery:</strong> Expert challenges for veterans</li>
        </ul>
    </div>

    <div class="mermaid">
    graph TD
        A["Difficulty Design"] --> B["Skill Progression"]
        A --> C["Challenge Types"]
        A --> D["Player Adaptation"]
        
        B --> E["Learning Curve"]
        B --> F["Skill Gates"]
        B --> G["Mastery"]
        
        C --> H["Mechanical"]
        C --> I["Strategic"]
        C --> J["Knowledge"]
        
        D --> K["Dynamic Difficulty"]
        D --> L["Difficulty Modes"]
        D --> M["Assists"]
    </div>

    <h2>Interactive Difficulty Testing Lab</h2>
    
    <div class="canvas-wrapper" style="text-align: center;">
        <canvas id="difficultyCanvas" width="800" height="600" style="border: 1px solid #333; display: inline-block;"></canvas>
    </div>
    <div style="text-align: center; margin-top: 10px;">
        <p>Play the game and watch how difficulty adapts to your performance! See real-time metrics and adjustments!</p>
        
        <!-- Game Controls -->
        <div style="margin: 10px auto; padding: 10px; background-color: rgba(0,0,0,0.3); border-radius: 5px; max-width: 800px;">
            <p style="color: white; margin: 5px;">Controls: Arrow Keys/WASD to move, Click to shoot</p>
        </div>
        
        <!-- Difficulty Settings -->
        <div style="margin: 10px auto; padding: 10px; background-color: rgba(0,0,0,0.3); border-radius: 5px; max-width: 800px;">
            <p style="color: white; margin: 5px;">Difficulty System:</p>
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 5px;">
                <button onclick="setDifficultyMode('static')" class="diff-btn active" id="static-btn">📊 Static</button>
                <button onclick="setDifficultyMode('dynamic')" class="diff-btn" id="dynamic-btn">🔄 Dynamic (DDA)</button>
                <button onclick="setDifficultyMode('rubberband')" class="diff-btn" id="rubberband-btn">🏎️ Rubber Band</button>
                <button onclick="setDifficultyMode('flow')" class="diff-btn" id="flow-btn">🌊 Flow State</button>
                <button onclick="setDifficultyMode('adaptive')" class="diff-btn" id="adaptive-btn">🧠 Adaptive AI</button>
                <button onclick="setDifficultyMode('custom')" class="diff-btn" id="custom-btn">⚙️ Custom</button>
            </div>
        </div>
        
        <!-- Manual Difficulty -->
        <div style="margin-top: 10px;">
            <label>Base Difficulty: <input type="range" id="baseDifficulty" min="1" max="10" value="5" onchange="updateParam('baseDifficulty', this.value)"> <span id="baseDifficultyDisplay">5</span></label>
            <label>Curve Type: 
                <select id="curveType" onchange="setCurveType(this.value)">
                    <option value="linear">Linear</option>
                    <option value="exponential">Exponential</option>
                    <option value="logarithmic">Logarithmic</option>
                    <option value="sigmoid" selected>Sigmoid (S-curve)</option>
                    <option value="wave">Wave</option>
                    <option value="stepped">Stepped</option>
                </select>
            </label>
        </div>
        
        <!-- Challenge Parameters -->
        <div style="margin-top: 10px;">
            <h4 style="color: white;">Challenge Parameters:</h4>
            <label>Enemy Speed: <input type="range" id="enemySpeed" min="0.5" max="3" step="0.1" value="1" onchange="updateParam('enemySpeed', this.value)"> <span id="enemySpeedDisplay">1.0</span>x</label>
            <label>Enemy Count: <input type="range" id="enemyCount" min="1" max="20" value="5" onchange="updateParam('enemyCount', this.value)"> <span id="enemyCountDisplay">5</span></label>
            <label>Enemy Health: <input type="range" id="enemyHealth" min="1" max="10" value="3" onchange="updateParam('enemyHealth', this.value)"> <span id="enemyHealthDisplay">3</span></label>
        </div>
        
        <div style="margin-top: 10px;">
            <label>Spawn Rate: <input type="range" id="spawnRate" min="500" max="5000" step="100" value="2000" onchange="updateParam('spawnRate', this.value)"> <span id="spawnRateDisplay">2000</span>ms</label>
            <label>Projectile Speed: <input type="range" id="projectileSpeed" min="0.5" max="3" step="0.1" value="1" onchange="updateParam('projectileSpeed', this.value)"> <span id="projectileSpeedDisplay">1.0</span>x</label>
            <label>Power-up Frequency: <input type="range" id="powerupFreq" min="0" max="100" value="20" onchange="updateParam('powerupFreq', this.value)"> <span id="powerupFreqDisplay">20</span>%</label>
        </div>
        
        <!-- Assists & Accessibility -->
        <div style="margin-top: 10px;">
            <h4 style="color: white;">Difficulty Assists:</h4>
            <label><input type="checkbox" id="aimAssist" onchange="toggleAssist('aimAssist')"> Aim Assist</label>
            <label><input type="checkbox" id="invulnerability" onchange="toggleAssist('invulnerability')"> Brief Invulnerability</label>
            <label><input type="checkbox" id="slowMotion" onchange="toggleAssist('slowMotion')"> Slow Motion</label>
            <label><input type="checkbox" id="extraLives" onchange="toggleAssist('extraLives')"> Extra Lives</label>
            <label><input type="checkbox" id="enemyOutlines" onchange="toggleAssist('enemyOutlines')"> Enemy Outlines</label>
            <label><input type="checkbox" id="autoFire" onchange="toggleAssist('autoFire')"> Auto Fire</label>
        </div>
        
        <!-- Preset Difficulties -->
        <div style="margin-top: 10px;">
            <button onclick="setPreset('tourist')">📸 Tourist</button>
            <button onclick="setPreset('easy')">😊 Easy</button>
            <button onclick="setPreset('normal')">🎮 Normal</button>
            <button onclick="setPreset('hard')">💪 Hard</button>
            <button onclick="setPreset('nightmare')">😈 Nightmare</button>
            <button onclick="setPreset('impossible')">💀 Impossible</button>
        </div>
        
        <!-- Metrics Display -->
        <div style="margin-top: 10px;">
            <label><input type="checkbox" id="showMetrics" checked> Show Metrics</label>
            <label><input type="checkbox" id="showGraph" checked> Difficulty Graph</label>
            <label><input type="checkbox" id="showFlow" checked> Flow Indicator</label>
            <label><input type="checkbox" id="showAdaptation"> Adaptation Log</label>
        </div>
        
        <!-- Player Stats -->
        <div style="margin-top: 10px; background-color: rgba(0,0,0,0.5); padding: 10px; border-radius: 5px;">
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 10px;">
                <div style="color: white;">
                    <strong>Performance</strong><br>
                    Score: <span id="playerScore">0</span><br>
                    Deaths: <span id="playerDeaths">0</span><br>
                    Accuracy: <span id="playerAccuracy">0</span>%
                </div>
                <div style="color: white;">
                    <strong>Current Difficulty</strong><br>
                    Level: <span id="currentDifficulty">5.0</span><br>
                    Multiplier: <span id="diffMultiplier">1.0</span>x<br>
                    Rank: <span id="diffRank">Normal</span>
                </div>
                <div style="color: white;">
                    <strong>Flow State</strong><br>
                    Status: <span id="flowStatus">Balanced</span><br>
                    Challenge: <span id="challengeLevel">50</span>%<br>
                    Skill: <span id="skillLevel">50</span>%
                </div>
                <div style="color: white;">
                    <strong>Adaptation</strong><br>
                    Trend: <span id="adaptTrend">Stable</span><br>
                    Adjustments: <span id="adjustCount">0</span><br>
                    Confidence: <span id="confidence">50</span>%
                </div>
            </div>
        </div>
    </div>

    <style>
        .diff-btn {
            padding: 8px;
            border: 2px solid transparent;
            background-color: #555;
            color: white;
            cursor: pointer;
            border-radius: 5px;
            transition: all 0.3s;
            font-size: 12px;
        }
        .diff-btn:hover {
            background-color: #666;
            border-color: #888;
        }
        .diff-btn.active {
            background-color: #4CAF50;
            border-color: #66BB6A;
        }
    </style>

    <script>
        console.log('Difficulty Testing Lab starting...');

        const canvas = document.getElementById('difficultyCanvas');
        const ctx = canvas.getContext('2d');

        // Input handling
        const keys = {};
        const mouse = { x: 0, y: 0, clicked: false };

        window.addEventListener('keydown', e => keys[e.key.toLowerCase()] = true);
        window.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);
        
        canvas.addEventListener('mousemove', e => {
            const rect = canvas.getBoundingClientRect();
            mouse.x = e.clientX - rect.left;
            mouse.y = e.clientY - rect.top;
        });
        
        canvas.addEventListener('click', e => mouse.clicked = true);

        // Difficulty System
        class DifficultySystem {
            constructor() {
                this.mode = 'static';
                this.baseDifficulty = 5;
                this.currentDifficulty = 5;
                this.curveType = 'sigmoid';
                
                // Game parameters
                this.params = {
                    enemySpeed: 1.0,
                    enemyCount: 5,
                    enemyHealth: 3,
                    spawnRate: 2000,
                    projectileSpeed: 1.0,
                    powerupFreq: 20
                };
                
                // Assists
                this.assists = {
                    aimAssist: false,
                    invulnerability: false,
                    slowMotion: false,
                    extraLives: false,
                    enemyOutlines: false,
                    autoFire: false
                };
                
                // Player metrics
                this.metrics = {
                    score: 0,
                    deaths: 0,
                    kills: 0,
                    shots: 0,
                    hits: 0,
                    timePlayed: 0,
                    recentDeaths: [],
                    recentKills: [],
                    performanceHistory: []
                };
                
                // Flow state tracking
                this.flowState = {
                    challenge: 50,
                    skill: 50,
                    status: 'Balanced'
                };
                
                // Dynamic difficulty adjustment
                this.dda = {
                    enabled: false,
                    adjustmentRate: 0.1,
                    adjustmentCount: 0,
                    trend: 'Stable',
                    confidence: 50,
                    lastAdjustment: 0
                };
                
                // Difficulty history for graph
                this.difficultyHistory = [];
                this.maxHistoryLength = 100;
            }
            
            update(deltaTime) {
                this.metrics.timePlayed += deltaTime;
                
                // Update recent metrics (last 10 seconds)
                const currentTime = Date.now();
                this.metrics.recentDeaths = this.metrics.recentDeaths.filter(t => currentTime - t < 10000);
                this.metrics.recentKills = this.metrics.recentKills.filter(t => currentTime - t < 10000);
                
                // Calculate performance
                const performance = this.calculatePerformance();
                this.metrics.performanceHistory.push(performance);
                if (this.metrics.performanceHistory.length > 20) {
                    this.metrics.performanceHistory.shift();
                }
                
                // Update flow state
                this.updateFlowState(performance);
                
                // Apply difficulty mode
                switch (this.mode) {
                    case 'dynamic':
                        this.applyDynamicDifficulty(performance);
                        break;
                    case 'rubberband':
                        this.applyRubberBanding();
                        break;
                    case 'flow':
                        this.applyFlowBasedDifficulty();
                        break;
                    case 'adaptive':
                        this.applyAdaptiveAI(performance);
                        break;
                    default:
                        this.currentDifficulty = this.baseDifficulty;
                }
                
                // Apply difficulty curve
                this.currentDifficulty = this.applyCurve(this.currentDifficulty);
                
                // Record history
                this.difficultyHistory.push(this.currentDifficulty);
                if (this.difficultyHistory.length > this.maxHistoryLength) {
                    this.difficultyHistory.shift();
                }
                
                // Update UI
                this.updateUI();
            }
            
            calculatePerformance() {
                // Composite performance score (0-100)
                let performance = 50;
                
                // Accuracy component
                const accuracy = this.metrics.shots > 0 ? 
                    (this.metrics.hits / this.metrics.shots) * 100 : 0;
                performance += (accuracy - 50) * 0.3;
                
                // Death rate component
                const deathRate = this.metrics.recentDeaths.length;
                performance -= deathRate * 5;
                
                // Kill rate component
                const killRate = this.metrics.recentKills.length;
                performance += killRate * 2;
                
                // Score rate component
                const scoreRate = this.metrics.score / Math.max(1, this.metrics.timePlayed / 1000);
                performance += scoreRate * 0.5;
                
                return Math.max(0, Math.min(100, performance));
            }
            
            updateFlowState(performance) {
                // Update skill estimation
                this.flowState.skill = performance;
                
                // Update challenge level
                this.flowState.challenge = this.currentDifficulty * 10;
                
                // Determine flow status
                const difference = Math.abs(this.flowState.skill - this.flowState.challenge);
                
                if (difference < 10) {
                    this.flowState.status = 'Flow';
                } else if (this.flowState.skill > this.flowState.challenge + 20) {
                    this.flowState.status = 'Bored';
                } else if (this.flowState.skill < this.flowState.challenge - 20) {
                    this.flowState.status = 'Frustrated';
                } else {
                    this.flowState.status = 'Balanced';
                }
            }
            
            applyDynamicDifficulty(performance) {
                const targetPerformance = 65; // Target 65% performance
                const difference = performance - targetPerformance;
                
                // Adjust difficulty based on performance
                if (Math.abs(difference) > 10) {
                    const adjustment = difference * this.dda.adjustmentRate * 0.01;
                    this.currentDifficulty = Math.max(1, Math.min(10, 
                        this.currentDifficulty - adjustment));
                    
                    this.dda.adjustmentCount++;
                    this.dda.lastAdjustment = Date.now();
                    
                    // Update trend
                    if (adjustment > 0) {
                        this.dda.trend = 'Easier';
                    } else if (adjustment < 0) {
                        this.dda.trend = 'Harder';
                    } else {
                        this.dda.trend = 'Stable';
                    }
                }
                
                // Update confidence
                const stability = this.metrics.performanceHistory.length > 5 ?
                    this.calculateStability() : 50;
                this.dda.confidence = stability;
            }
            
            applyRubberBanding() {
                // Keep players close together in skill
                const targetDifficulty = this.baseDifficulty;
                const maxDeviation = 2;
                
                // Pull difficulty back toward target
                const difference = this.currentDifficulty - targetDifficulty;
                if (Math.abs(difference) > maxDeviation) {
                    const pullStrength = 0.1;
                    this.currentDifficulty -= difference * pullStrength;
                }
            }
            
            applyFlowBasedDifficulty() {
                // Maintain flow state
                const skillChallengeDiff = this.flowState.skill - this.flowState.challenge;
                
                if (Math.abs(skillChallengeDiff) > 5) {
                    // Adjust to maintain flow
                    const adjustment = skillChallengeDiff * 0.01;
                    this.currentDifficulty += adjustment;
                    this.currentDifficulty = Math.max(1, Math.min(10, this.currentDifficulty));
                }
            }
            
            applyAdaptiveAI(performance) {
                // Learn player patterns and adapt
                if (this.metrics.performanceHistory.length < 5) return;
                
                // Analyze recent performance trend
                const recentAvg = this.metrics.performanceHistory.slice(-5)
                    .reduce((a, b) => a + b, 0) / 5;
                const olderAvg = this.metrics.performanceHistory.slice(-10, -5)
                    .reduce((a, b) => a + b, 0) / Math.min(5, this.metrics.performanceHistory.length - 5);
                
                const trend = recentAvg - olderAvg;
                
                // Predict future performance
                const predictedPerformance = recentAvg + trend * 0.5;
                
                // Adjust difficulty to challenge predicted skill
                const targetChallenge = predictedPerformance * 0.01 * 10;
                const adjustment = (targetChallenge - this.currentDifficulty) * 0.2;
                
                this.currentDifficulty += adjustment;
                this.currentDifficulty = Math.max(1, Math.min(10, this.currentDifficulty));
            }
            
            applyCurve(difficulty) {
                const t = this.metrics.timePlayed / 60000; // Minutes played
                
                switch (this.curveType) {
                    case 'linear':
                        return difficulty + t * 0.1;
                        
                    case 'exponential':
                        return difficulty * Math.pow(1.01, t);
                        
                    case 'logarithmic':
                        return difficulty + Math.log(t + 1);
                        
                    case 'sigmoid':
                        // S-curve
                        const midpoint = 10;
                        const steepness = 0.5;
                        return difficulty * (1 + 1 / (1 + Math.exp(-steepness * (t - midpoint))));
                        
                    case 'wave':
                        return difficulty + Math.sin(t * 0.5) * 2;
                        
                    case 'stepped':
                        return difficulty + Math.floor(t / 5);
                        
                    default:
                        return difficulty;
                }
            }
            
            calculateStability() {
                // Calculate how stable the performance is
                const history = this.metrics.performanceHistory;
                if (history.length < 2) return 50;
                
                const mean = history.reduce((a, b) => a + b, 0) / history.length;
                const variance = history.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / history.length;
                const stability = Math.max(0, 100 - variance);
                
                return stability;
            }
            
            getDifficultyMultiplier() {
                return this.currentDifficulty / 5;
            }
            
            getDifficultyRank() {
                if (this.currentDifficulty < 2) return 'Tourist';
                if (this.currentDifficulty < 4) return 'Easy';
                if (this.currentDifficulty < 6) return 'Normal';
                if (this.currentDifficulty < 8) return 'Hard';
                if (this.currentDifficulty < 9.5) return 'Nightmare';
                return 'Impossible';
            }
            
            updateUI() {
                // Update all UI elements
                document.getElementById('playerScore').textContent = Math.floor(this.metrics.score);
                document.getElementById('playerDeaths').textContent = this.metrics.deaths;
                document.getElementById('playerAccuracy').textContent = 
                    this.metrics.shots > 0 ? Math.floor((this.metrics.hits / this.metrics.shots) * 100) : 0;
                
                document.getElementById('currentDifficulty').textContent = this.currentDifficulty.toFixed(1);
                document.getElementById('diffMultiplier').textContent = this.getDifficultyMultiplier().toFixed(1);
                document.getElementById('diffRank').textContent = this.getDifficultyRank();
                
                document.getElementById('flowStatus').textContent = this.flowState.status;
                document.getElementById('challengeLevel').textContent = Math.floor(this.flowState.challenge);
                document.getElementById('skillLevel').textContent = Math.floor(this.flowState.skill);
                
                document.getElementById('adaptTrend').textContent = this.dda.trend;
                document.getElementById('adjustCount').textContent = this.dda.adjustmentCount;
                document.getElementById('confidence').textContent = Math.floor(this.dda.confidence);
            }
        }

        // Simple game for testing difficulty
        class TestGame {
            constructor() {
                this.player = {
                    x: canvas.width / 2,
                    y: canvas.height - 50,
                    size: 20,
                    speed: 5,
                    health: 100,
                    maxHealth: 100
                };
                
                this.enemies = [];
                this.projectiles = [];
                this.powerups = [];
                
                this.lastSpawn = 0;
                this.gameTime = 0;
            }
            
            update(deltaTime, difficultySystem) {
                this.gameTime += deltaTime;
                
                // Player movement
                if (keys['a'] || keys['arrowleft']) this.player.x -= this.player.speed;
                if (keys['d'] || keys['arrowright']) this.player.x += this.player.speed;
                if (keys['w'] || keys['arrowup']) this.player.y -= this.player.speed;
                if (keys['s'] || keys['arrowdown']) this.player.y += this.player.speed;
                
                // Keep player in bounds
                this.player.x = Math.max(this.player.size, Math.min(canvas.width - this.player.size, this.player.x));
                this.player.y = Math.max(this.player.size, Math.min(canvas.height - this.player.size, this.player.y));
                
                // Shooting
                if (mouse.clicked || difficultySystem.assists.autoFire) {
                    this.shoot(difficultySystem);
                    mouse.clicked = false;
                }
                
                // Spawn enemies
                const spawnRate = difficultySystem.params.spawnRate / difficultySystem.getDifficultyMultiplier();
                if (Date.now() - this.lastSpawn > spawnRate) {
                    this.spawnEnemy(difficultySystem);
                    this.lastSpawn = Date.now();
                }
                
                // Update enemies
                const timeScale = difficultySystem.assists.slowMotion ? 0.5 : 1.0;
                
                this.enemies = this.enemies.filter(enemy => {
                    // Move toward player
                    const dx = this.player.x - enemy.x;
                    const dy = this.player.y - enemy.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist > 0) {
                        enemy.x += (dx / dist) * enemy.speed * deltaTime * 0.001 * timeScale;
                        enemy.y += (dy / dist) * enemy.speed * deltaTime * 0.001 * timeScale;
                    }
                    
                    // Check collision with player
                    if (!difficultySystem.assists.invulnerability) {
                        if (dist < this.player.size + enemy.size) {
                            this.player.health -= 10;
                            difficultySystem.metrics.deaths++;
                            difficultySystem.metrics.recentDeaths.push(Date.now());
                            return false;
                        }
                    }
                    
                    return enemy.health > 0 && enemy.y < canvas.height + 50;
                });
                
                // Update projectiles
                this.projectiles = this.projectiles.filter(proj => {
                    proj.y -= proj.speed * deltaTime * 0.001 * timeScale;
                    
                    // Check enemy hits
                    for (const enemy of this.enemies) {
                        const dx = proj.x - enemy.x;
                        const dy = proj.y - enemy.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        
                        if (dist < enemy.size) {
                            enemy.health--;
                            difficultySystem.metrics.hits++;
                            
                            if (enemy.health <= 0) {
                                difficultySystem.metrics.kills++;
                                difficultySystem.metrics.recentKills.push(Date.now());
                                difficultySystem.metrics.score += 100 * difficultySystem.getDifficultyMultiplier();
                                
                                // Chance to spawn powerup
                                if (Math.random() < difficultySystem.params.powerupFreq / 100) {
                                    this.powerups.push({
                                        x: enemy.x,
                                        y: enemy.y,
                                        type: 'health'
                                    });
                                }
                            }
                            
                            return false;
                        }
                    }
                    
                    return proj.y > 0;
                });
                
                // Update powerups
                this.powerups = this.powerups.filter(powerup => {
                    const dx = this.player.x - powerup.x;
                    const dy = this.player.y - powerup.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist < this.player.size) {
                        if (powerup.type === 'health') {
                            this.player.health = Math.min(this.player.maxHealth, this.player.health + 20);
                        }
                        return false;
                    }
                    
                    return true;
                });
            }
            
            shoot(difficultySystem) {
                let targetX = mouse.x;
                let targetY = mouse.y;
                
                // Aim assist
                if (difficultySystem.assists.aimAssist && this.enemies.length > 0) {
                    // Find nearest enemy
                    let nearestEnemy = null;
                    let nearestDist = Infinity;
                    
                    for (const enemy of this.enemies) {
                        const dist = Math.sqrt(
                            Math.pow(enemy.x - this.player.x, 2) + 
                            Math.pow(enemy.y - this.player.y, 2)
                        );
                        
                        if (dist < nearestDist) {
                            nearestDist = dist;
                            nearestEnemy = enemy;
                        }
                    }
                    
                    if (nearestEnemy) {
                        // Adjust aim toward enemy
                        const aimStrength = 0.5;
                        targetX = mouse.x * (1 - aimStrength) + nearestEnemy.x * aimStrength;
                        targetY = mouse.y * (1 - aimStrength) + nearestEnemy.y * aimStrength;
                    }
                }
                
                const dx = targetX - this.player.x;
                const dy = targetY - this.player.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                if (dist > 0) {
                    this.projectiles.push({
                        x: this.player.x,
                        y: this.player.y,
                        vx: (dx / dist) * 10,
                        vy: (dy / dist) * 10,
                        speed: 300 * difficultySystem.params.projectileSpeed
                    });
                    
                    difficultySystem.metrics.shots++;
                }
            }
            
            spawnEnemy(difficultySystem) {
                const count = Math.min(difficultySystem.params.enemyCount, 
                    Math.floor(difficultySystem.params.enemyCount * difficultySystem.getDifficultyMultiplier()));
                
                for (let i = 0; i < count; i++) {
                    this.enemies.push({
                        x: Math.random() * canvas.width,
                        y: -50,
                        size: 15 + Math.random() * 10,
                        speed: (50 + Math.random() * 50) * difficultySystem.params.enemySpeed,
                        health: Math.floor(difficultySystem.params.enemyHealth * difficultySystem.getDifficultyMultiplier()),
                        maxHealth: Math.floor(difficultySystem.params.enemyHealth * difficultySystem.getDifficultyMultiplier()),
                        color: `hsl(${Math.random() * 60}, 70%, 50%)`
                    });
                }
            }
            
            render(ctx, difficultySystem) {
                // Clear
                ctx.fillStyle = '#222';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Draw grid
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.05)';
                ctx.lineWidth = 1;
                for (let x = 0; x < canvas.width; x += 50) {
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, canvas.height);
                    ctx.stroke();
                }
                for (let y = 0; y < canvas.height; y += 50) {
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(canvas.width, y);
                    ctx.stroke();
                }
                
                // Draw difficulty graph
                if (document.getElementById('showGraph').checked) {
                    this.renderDifficultyGraph(ctx, difficultySystem);
                }
                
                // Draw flow indicator
                if (document.getElementById('showFlow').checked) {
                    this.renderFlowIndicator(ctx, difficultySystem);
                }
                
                // Draw powerups
                for (const powerup of this.powerups) {
                    ctx.fillStyle = '#00FF00';
                    ctx.beginPath();
                    ctx.arc(powerup.x, powerup.y, 10, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.fillStyle = '#FFFFFF';
                    ctx.font = '12px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('+', powerup.x, powerup.y + 4);
                }
                
                // Draw enemies
                for (const enemy of this.enemies) {
                    // Enemy outline assist
                    if (difficultySystem.assists.enemyOutlines) {
                        ctx.strokeStyle = '#FF0000';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.arc(enemy.x, enemy.y, enemy.size + 5, 0, Math.PI * 2);
                        ctx.stroke();
                    }
                    
                    ctx.fillStyle = enemy.color;
                    ctx.beginPath();
                    ctx.arc(enemy.x, enemy.y, enemy.size, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Health bar
                    if (enemy.health < enemy.maxHealth) {
                        ctx.fillStyle = 'rgba(255, 0, 0, 0.5)';
                        ctx.fillRect(enemy.x - 15, enemy.y - enemy.size - 10, 30, 3);
                        
                        ctx.fillStyle = 'rgba(0, 255, 0, 0.8)';
                        ctx.fillRect(enemy.x - 15, enemy.y - enemy.size - 10, 
                            30 * (enemy.health / enemy.maxHealth), 3);
                    }
                }
                
                // Draw projectiles
                ctx.fillStyle = '#FFFF00';
                for (const proj of this.projectiles) {
                    ctx.beginPath();
                    ctx.arc(proj.x, proj.y, 3, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // Draw player
                ctx.fillStyle = '#4CAF50';
                ctx.beginPath();
                ctx.arc(this.player.x, this.player.y, this.player.size, 0, Math.PI * 2);
                ctx.fill();
                
                // Player health bar
                const barWidth = 100;
                const barHeight = 10;
                const barX = 10;
                const barY = canvas.height - 30;
                
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(barX, barY, barWidth, barHeight);
                
                ctx.fillStyle = this.player.health > 30 ? '#4CAF50' : '#FF0000';
                ctx.fillRect(barX, barY, barWidth * (this.player.health / this.player.maxHealth), barHeight);
                
                ctx.strokeStyle = '#FFFFFF';
                ctx.strokeRect(barX, barY, barWidth, barHeight);
                
                // Show metrics
                if (document.getElementById('showMetrics').checked) {
                    this.renderMetrics(ctx, difficultySystem);
                }
            }
            
            renderDifficultyGraph(ctx, difficultySystem) {
                const graphX = canvas.width - 170;
                const graphY = 20;
                const graphWidth = 150;
                const graphHeight = 80;
                
                // Background
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(graphX, graphY, graphWidth, graphHeight);
                
                // Draw graph
                ctx.strokeStyle = '#4CAF50';
                ctx.lineWidth = 2;
                ctx.beginPath();
                
                const history = difficultySystem.difficultyHistory;
                for (let i = 0; i < history.length; i++) {
                    const x = graphX + (i / history.length) * graphWidth;
                    const y = graphY + graphHeight - (history[i] / 10) * graphHeight;
                    
                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                ctx.stroke();
                
                // Current difficulty line
                const currentY = graphY + graphHeight - (difficultySystem.currentDifficulty / 10) * graphHeight;
                ctx.strokeStyle = '#FFD700';
                ctx.lineWidth = 1;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.moveTo(graphX, currentY);
                ctx.lineTo(graphX + graphWidth, currentY);
                ctx.stroke();
                ctx.setLineDash([]);
                
                // Labels
                ctx.fillStyle = '#FFFFFF';
                ctx.font = '10px Arial';
                ctx.fillText('Difficulty', graphX + 5, graphY + 15);
                ctx.fillText('10', graphX - 15, graphY + 5);
                ctx.fillText('5', graphX - 15, graphY + graphHeight / 2);
                ctx.fillText('0', graphX - 15, graphY + graphHeight);
            }
            
            renderFlowIndicator(ctx, difficultySystem) {
                const x = canvas.width / 2;
                const y = 40;
                const width = 200;
                const height = 20;
                
                // Background
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(x - width/2, y - height/2, width, height);
                
                // Flow zones
                const zones = [
                    { start: 0, end: 0.3, color: '#FF0000', label: 'Frustration' },
                    { start: 0.3, end: 0.7, color: '#4CAF50', label: 'Flow' },
                    { start: 0.7, end: 1, color: '#FFA500', label: 'Boredom' }
                ];
                
                zones.forEach(zone => {
                    ctx.fillStyle = zone.color;
                    ctx.globalAlpha = 0.3;
                    ctx.fillRect(
                        x - width/2 + zone.start * width,
                        y - height/2,
                        (zone.end - zone.start) * width,
                        height
                    );
                    ctx.globalAlpha = 1;
                });
                
                // Current position
                const skillRatio = difficultySystem.flowState.skill / 100;
                const markerX = x - width/2 + skillRatio * width;
                
                ctx.fillStyle = '#FFFFFF';
                ctx.beginPath();
                ctx.moveTo(markerX, y - height/2 - 5);
                ctx.lineTo(markerX - 5, y - height/2);
                ctx.lineTo(markerX + 5, y - height/2);
                ctx.closePath();
                ctx.fill();
                
                // Label
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(difficultySystem.flowState.status, x, y + height/2 + 15);
            }
            
            renderMetrics(ctx, difficultySystem) {
                ctx.fillStyle = '#FFFFFF';
                ctx.font = '12px Arial';
                ctx.textAlign = 'left';
                
                const metrics = [
                    `Time: ${Math.floor(difficultySystem.metrics.timePlayed / 1000)}s`,
                    `K/D: ${difficultySystem.metrics.kills}/${difficultySystem.metrics.deaths}`,
                    `Enemies: ${this.enemies.length}`,
                    `Difficulty: ${difficultySystem.currentDifficulty.toFixed(1)}`
                ];
                
                metrics.forEach((text, i) => {
                    ctx.fillText(text, 10, 20 + i * 15);
                });
            }
        }

        // Initialize systems
        const difficultySystem = new DifficultySystem();
        const game = new TestGame();

        // UI Functions
        window.setDifficultyMode = function(mode) {
            document.querySelectorAll('.diff-btn').forEach(btn => btn.classList.remove('active'));
            document.getElementById(mode + '-btn').classList.add('active');
            
            difficultySystem.mode = mode;
            difficultySystem.dda.enabled = mode === 'dynamic';
            difficultySystem.dda.adjustmentCount = 0;
        };

        window.updateParam = function(param, value) {
            document.getElementById(param + 'Display').textContent = 
                param.includes('Speed') || param.includes('Health') ? value : value;
            
            if (param === 'baseDifficulty') {
                difficultySystem.baseDifficulty = parseFloat(value);
                difficultySystem.currentDifficulty = parseFloat(value);
            } else {
                difficultySystem.params[param] = parseFloat(value);
            }
        };

        window.setCurveType = function(type) {
            difficultySystem.curveType = type;
        };

        window.toggleAssist = function(assist) {
            difficultySystem.assists[assist] = document.getElementById(assist).checked;
        };

        window.setPreset = function(preset) {
            const presets = {
                tourist: { difficulty: 1, assists: ['aimAssist', 'invulnerability', 'extraLives', 'enemyOutlines'] },
                easy: { difficulty: 3, assists: ['aimAssist', 'extraLives'] },
                normal: { difficulty: 5, assists: [] },
                hard: { difficulty: 7, assists: [] },
                nightmare: { difficulty: 9, assists: [] },
                impossible: { difficulty: 10, assists: [] }
            };
            
            const p = presets[preset];
            if (p) {
                document.getElementById('baseDifficulty').value = p.difficulty;
                updateParam('baseDifficulty', p.difficulty);
                
                // Reset all assists
                Object.keys(difficultySystem.assists).forEach(key => {
                    difficultySystem.assists[key] = false;
                    const checkbox = document.getElementById(key);
                    if (checkbox) checkbox.checked = false;
                });
                
                // Enable preset assists
                p.assists.forEach(assist => {
                    difficultySystem.assists[assist] = true;
                    const checkbox = document.getElementById(assist);
                    if (checkbox) checkbox.checked = true;
                });
            }
        };

        // Game loop
        let lastTime = performance.now();
        
        function gameLoop() {
            const currentTime = performance.now();
            const deltaTime = currentTime - lastTime;
            lastTime = currentTime;
            
            // Update systems
            difficultySystem.update(deltaTime);
            game.update(deltaTime, difficultySystem);
            
            // Render
            game.render(ctx, difficultySystem);
            
            requestAnimationFrame(gameLoop);
        }
        
        gameLoop();
        console.log('Difficulty Testing Lab initialized!');
    </script>

    <h2>Difficulty Balancing Implementation in Python</h2>
    
    <pre class="language-python"><code>import math
import random
from typing import Dict, List, Optional, Tuple
from dataclasses import dataclass
from enum import Enum
import numpy as np

class DifficultyMode(Enum):
    STATIC = "static"
    DYNAMIC = "dynamic"
    ADAPTIVE = "adaptive"
    FLOW_BASED = "flow"
    RUBBER_BAND = "rubberband"

class FlowState(Enum):
    BOREDOM = "boredom"
    FLOW = "flow"
    FRUSTRATION = "frustration"
    ANXIETY = "anxiety"

@dataclass
class PlayerMetrics:
    """Track player performance metrics"""
    score: float = 0
    deaths: int = 0
    kills: int = 0
    time_played: float = 0
    accuracy: float = 0
    reaction_time: List[float] = None
    success_rate: float = 0.5
    
    def __post_init__(self):
        if self.reaction_time is None:
            self.reaction_time = []

class DifficultyManager:
    """Comprehensive difficulty management system"""
    
    def __init__(self, base_difficulty: float = 5.0):
        self.base_difficulty = base_difficulty
        self.current_difficulty = base_difficulty
        self.mode = DifficultyMode.STATIC
        
        # Player metrics
        self.metrics = PlayerMetrics()
        self.performance_history = []
        self.max_history = 100
        
        # Flow state
        self.flow_state = FlowState.FLOW
        self.player_skill = 50  # 0-100
        self.challenge_level = 50  # 0-100
        
        # Dynamic difficulty adjustment
        self.dda_enabled = False
        self.dda_rate = 0.1
        self.target_success_rate = 0.65
        
        # Difficulty parameters
        self.parameters = {
            'enemy_speed': 1.0,
            'enemy_health': 1.0,
            'enemy_damage': 1.0,
            'spawn_rate': 1.0,
            'player_damage': 1.0,
            'resource_availability': 1.0,
            'puzzle_complexity': 1.0
        }
    
    def update(self, dt: float):
        """Update difficulty based on current mode"""
        self.metrics.time_played += dt
        
        # Calculate current performance
        performance = self.calculate_performance()
        self.performance_history.append(performance)
        
        if len(self.performance_history) > self.max_history:
            self.performance_history.pop(0)
        
        # Update based on mode
        if self.mode == DifficultyMode.DYNAMIC:
            self.update_dynamic_difficulty(performance)
        elif self.mode == DifficultyMode.ADAPTIVE:
            self.update_adaptive_difficulty()
        elif self.mode == DifficultyMode.FLOW_BASED:
            self.update_flow_based_difficulty()
        elif self.mode == DifficultyMode.RUBBER_BAND:
            self.update_rubber_band_difficulty()
        
        # Update parameters based on difficulty
        self.update_parameters()
    
    def calculate_performance(self) -> float:
        """Calculate player performance (0-100)"""
        # Weighted performance calculation
        weights = {
            'success_rate': 0.3,
            'accuracy': 0.2,
            'death_rate': 0.2,
            'kill_rate': 0.2,
            'reaction': 0.1
        }
        
        performance = 0
        
        # Success rate component
        performance += self.metrics.success_rate * weights['success_rate'] * 100
        
        # Accuracy component
        performance += self.metrics.accuracy * weights['accuracy'] * 100
        
        # Death rate (inverse)
        death_rate = self.metrics.deaths / max(1, self.metrics.time_played / 60)
        performance += (1 - min(1, death_rate / 10)) * weights['death_rate'] * 100
        
        # Kill rate
        kill_rate = self.metrics.kills / max(1, self.metrics.time_played / 60)
        performance += min(1, kill_rate / 10) * weights['kill_rate'] * 100
        
        # Reaction time
        if self.metrics.reaction_time:
            avg_reaction = sum(self.metrics.reaction_time) / len(self.metrics.reaction_time)
            reaction_score = max(0, 1 - avg_reaction / 2)  # 2 seconds max
            performance += reaction_score * weights['reaction'] * 100
        
        return min(100, max(0, performance))
    
    def update_dynamic_difficulty(self, performance: float):
        """Dynamic Difficulty Adjustment (DDA)"""
        # Calculate performance error
        target_performance = self.target_success_rate * 100
        error = performance - target_performance
        
        # Adjust difficulty
        adjustment = -error * self.dda_rate * 0.01
        self.current_difficulty += adjustment
        
        # Clamp difficulty
        self.current_difficulty = max(1, min(10, self.current_difficulty))
    
    def update_adaptive_difficulty(self):
        """Machine learning-based adaptive difficulty"""
        if len(self.performance_history) < 10:
            return
        
        # Simple trend analysis
        recent = self.performance_history[-10:]
        older = self.performance_history[-20:-10] if len(self.performance_history) >= 20 else recent
        
        recent_avg = sum(recent) / len(recent)
        older_avg = sum(older) / len(older)
        
        # Predict future performance
        trend = recent_avg - older_avg
        predicted_performance = recent_avg + trend * 0.5
        
        # Adjust difficulty to match predicted skill
        target_difficulty = predicted_performance / 10
        adjustment = (target_difficulty - self.current_difficulty) * 0.2
        
        self.current_difficulty += adjustment
        self.current_difficulty = max(1, min(10, self.current_difficulty))
    
    def update_flow_based_difficulty(self):
        """Maintain flow state"""
        # Update skill estimation
        performance = self.calculate_performance()
        self.player_skill = performance
        
        # Update challenge level
        self.challenge_level = self.current_difficulty * 10
        
        # Determine flow state
        skill_challenge_ratio = self.player_skill / max(1, self.challenge_level)
        
        if 0.7 <= skill_challenge_ratio <= 1.3:
            self.flow_state = FlowState.FLOW
        elif skill_challenge_ratio < 0.5:
            self.flow_state = FlowState.FRUSTRATION
        elif skill_challenge_ratio > 2:
            self.flow_state = FlowState.BOREDOM
        else:
            self.flow_state = FlowState.ANXIETY
        
        # Adjust difficulty to maintain flow
        if self.flow_state == FlowState.BOREDOM:
            self.current_difficulty += 0.1
        elif self.flow_state == FlowState.FRUSTRATION:
            self.current_difficulty -= 0.1
        elif self.flow_state == FlowState.ANXIETY:
            self.current_difficulty -= 0.05
        
        self.current_difficulty = max(1, min(10, self.current_difficulty))
    
    def update_rubber_band_difficulty(self):
        """Keep difficulty close to baseline"""
        # Pull toward base difficulty
        difference = self.current_difficulty - self.base_difficulty
        pull_strength = 0.05
        
        if abs(difference) > 1:
            self.current_difficulty -= difference * pull_strength
    
    def update_parameters(self):
        """Update game parameters based on difficulty"""
        multiplier = self.current_difficulty / 5  # 5 is "normal"
        
        # Apply non-linear scaling
        self.parameters['enemy_speed'] = math.pow(multiplier, 0.8)
        self.parameters['enemy_health'] = math.pow(multiplier, 1.2)
        self.parameters['enemy_damage'] = math.pow(multiplier, 0.9)
        self.parameters['spawn_rate'] = math.pow(multiplier, 0.7)
        self.parameters['player_damage'] = math.pow(2 - multiplier, 0.5)
        self.parameters['resource_availability'] = math.pow(2 - multiplier, 0.3)
        self.parameters['puzzle_complexity'] = multiplier
    
    def get_difficulty_rank(self) -> str:
        """Get human-readable difficulty rank"""
        if self.current_difficulty < 2:
            return "Novice"
        elif self.current_difficulty < 4:
            return "Easy"
        elif self.current_difficulty < 6:
            return "Normal"
        elif self.current_difficulty < 8:
            return "Hard"
        elif self.current_difficulty < 9:
            return "Expert"
        else:
            return "Master"
    
    def apply_assists(self, assists: Dict[str, bool]):
        """Apply accessibility assists"""
        if assists.get('aim_assist'):
            self.parameters['aim_assist'] = 0.3
        
        if assists.get('damage_reduction'):
            self.parameters['enemy_damage'] *= 0.7
        
        if assists.get('resource_boost'):
            self.parameters['resource_availability'] *= 1.5

class DifficultyPresets:
    """Predefined difficulty settings"""
    
    TOURIST = {
        'base_difficulty': 1,
        'parameters': {
            'enemy_speed': 0.5,
            'enemy_health': 0.5,
            'enemy_damage': 0.3,
            'player_damage': 2.0,
            'resource_availability': 2.0
        },
        'assists': ['aim_assist', 'damage_reduction', 'resource_boost']
    }
    
    EASY = {
        'base_difficulty': 3,
        'parameters': {
            'enemy_speed': 0.7,
            'enemy_health': 0.7,
            'enemy_damage': 0.6,
            'player_damage': 1.5,
            'resource_availability': 1.5
        },
        'assists': ['aim_assist']
    }
    
    NORMAL = {
        'base_difficulty': 5,
        'parameters': {
            'enemy_speed': 1.0,
            'enemy_health': 1.0,
            'enemy_damage': 1.0,
            'player_damage': 1.0,
            'resource_availability': 1.0
        },
        'assists': []
    }
    
    HARD = {
        'base_difficulty': 7,
        'parameters': {
            'enemy_speed': 1.3,
            'enemy_health': 1.5,
            'enemy_damage': 1.5,
            'player_damage': 0.8,
            'resource_availability': 0.7
        },
        'assists': []
    }
    
    NIGHTMARE = {
        'base_difficulty': 9,
        'parameters': {
            'enemy_speed': 1.5,
            'enemy_health': 2.0,
            'enemy_damage': 2.0,
            'player_damage': 0.5,
            'resource_availability': 0.5
        },
        'assists': []
    }</code></pre>

    <h2>Best Practices</h2>
    
    <div style="background-color: #fff3e0; padding: 20px; border-radius: 10px; margin: 20px 0;">
        <h3>⚡ Difficulty Balancing Tips</h3>
        <ul>
            <li><strong>Start Easy:</strong> Better to hook players than frustrate them</li>
            <li><strong>Gradual Progression:</strong> Increase difficulty smoothly</li>
            <li><strong>Multiple Axes:</strong> Vary different challenge types</li>
            <li><strong>Player Choice:</strong> Let players adjust difficulty</li>
            <li><strong>Clear Feedback:</strong> Show when difficulty changes</li>
            <li><strong>Recovery Mechanics:</strong> Allow players to recover from failure</li>
            <li><strong>Skill Gates:</strong> Test mastery before progression</li>
            <li><strong>Analytics:</strong> Track and analyze player data</li>
        </ul>
    </div>

    <h2>Key Takeaways</h2>
    
    <div style="background-color: #f0f8ff; padding: 20px; border-radius: 10px; margin: 20px 0;">
        <ul>
            <li>📈 Difficulty curves shape player experience</li>
            <li>🎯 Flow state keeps players engaged</li>
            <li>🔄 Dynamic difficulty adapts to skill</li>
            <li>📊 Metrics inform balancing decisions</li>
            <li>♿ Accessibility options welcome all players</li>
            <li>🎮 Different modes suit different players</li>
            <li>🧠 AI can learn optimal difficulty</li>
            <li>⚖️ Balance challenge with fairness</li>
        </ul>
    </div>

    <h2>What's Next?</h2>
    
    <p>Now that you understand difficulty balancing, next we'll explore playtesting methods to validate your game design decisions!</p>

    <!-- Lesson Navigation -->
    <nav class="lesson-nav" aria-label="Lesson navigation">
        <a href="polish_sound.html" class="prev-lesson" aria-label="Previous lesson: Sound Design">Previous Lesson: Sound Design</a>
        <a href="polish_playtesting.html" class="next-lesson" aria-label="Next lesson: Playtesting Methods">Next Lesson: Playtesting Methods</a>
    </nav>
    
    </main>
    <script src="/js/course-enhancements.js" defer></script>
    <script src="/js/clipboard.js" defer></script>
</body>
</html>